<Type Name="Process" FullName="System.Diagnostics.Process">
  <Metadata><Meta Name="ms.openlocfilehash" Value="4b6bf6f299cf0346642cea501b760e0bcc0f3a76" /><Meta Name="ms.sourcegitcommit" Value="c181255cb311fdd498458b3f12418f773c97254a" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="pt-BR" /><Meta Name="ms.lasthandoff" Value="03/21/2019" /><Meta Name="ms.locfileid" Value="58320844" /></Metadata><TypeSignature Language="C#" Value="public class Process : System.ComponentModel.Component" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Process extends System.ComponentModel.Component" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Process" />
  <TypeSignature Language="VB.NET" Value="Public Class Process&#xA;Inherits Component" />
  <TypeSignature Language="C++ CLI" Value="public ref class Process : System::ComponentModel::Component" />
  <TypeSignature Language="F#" Value="type Process = class&#xA;    inherit Component" />
  <AssemblyInfo>
    <AssemblyName>System.Diagnostics.Process</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.ComponentModel.Component</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultEvent("Exited")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.DefaultProperty("StartInfo")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Diagnostics.MonitoringDescription("Provides access to local and remote processes, enabling starting and stopping of local processes.")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=1.0.5000.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Diagnostics.MonitoringDescription("ProcessDesc")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
      <AttributeName>System.ComponentModel.Designer("System.Diagnostics.Design.ProcessDesigner, System.Design, Version=2.0.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Fornece acesso a processos locais e remotos e permite que você inicie e pare os processos do sistema local.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Diagnostics.Process> componente fornece acesso a um processo que está em execução em um computador. Um processo, em termos mais simples, é um aplicativo em execução. Um thread é a unidade básica à qual o sistema operacional aloca tempo do processador. Um thread pode executar qualquer parte do código do processo, incluindo partes que está sendo executadas no momento por outro thread.  
  
 O <xref:System.Diagnostics.Process> componente é uma ferramenta útil para iniciar, parar, controlar e monitorar aplicativos. Você pode usar o <xref:System.Diagnostics.Process> componente, para obter uma lista dos processos em execução, ou você pode iniciar um novo processo. Um <xref:System.Diagnostics.Process> componente é usado para acessar os processos do sistema. Após um <xref:System.Diagnostics.Process> componente foi inicializado, ele pode ser usado para obter informações sobre o processo em execução. Essas informações incluem o conjunto de threads, os módulos carregados (arquivos. dll e .exe), e informações de desempenho, como a quantidade de memória que o processo está usando.  
  
 Esse tipo implementa o <xref:System.IDisposable> interface. Quando você terminar de usar o tipo, você deve descartá-lo diretamente ou indiretamente. Para descartar o tipo diretamente, chame seu <xref:System.IDisposable.Dispose%2A> método em um `try` / `finally` bloco. Para descartá-los indiretamente, usar uma construção de linguagem, como `using` (em c#) ou `Using` (no Visual Basic). Para obter mais informações, consulte a seção "Usando um objeto que implementa IDisposable" o <xref:System.IDisposable> tópico da interface.  
  
> [!NOTE]
>  processos de 32 bits não podem acessar os módulos de um processo de 64 bits. Se você tentar obter informações sobre um processo de 64 bits de um processo de 32 bits, você obterá um <xref:System.ComponentModel.Win32Exception> exceção. Por outro lado, um processo de 64 bits, pode acessar os módulos de um processo de 32 bits.  
  
 O componente do processo obtém informações sobre um grupo de propriedades ao mesmo tempo. Após o <xref:System.Diagnostics.Process> componente obteve informações sobre um membro de qualquer grupo, ele armazenar em cache os valores para as outras propriedades nesse grupo e não obter novas informações sobre os outros membros do grupo até que você chame o <xref:System.Diagnostics.Process.Refresh%2A> método. Portanto, um valor da propriedade não é garantido para ser qualquer mais recente do que a última chamada para o <xref:System.Diagnostics.Process.Refresh%2A> método. As divisões de grupo são dependentes do sistema operacional.  
  
 Se você tiver uma variável de caminho declarada em seu sistema, o uso de aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não está em seu caminho, e você adicioná-lo usando as aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente qualquer processo no `c:\mypath` ao iniciá-lo.  
  
 Um processo do sistema é identificado exclusivamente no sistema por seu identificador de processo. Assim como muitos recursos do Windows, um processo também é identificado por seu identificador, que pode não ser exclusivo no computador. Um identificador é o termo genérico para um identificador de um recurso. O sistema operacional persistir o identificador de processo, que pode é acessado por meio de <xref:System.Diagnostics.Process.Handle%2A> propriedade do <xref:System.Diagnostics.Process> componente, mesmo quando o processo foi encerrado. Assim, você pode obter informações de administrativas do processo, como o <xref:System.Diagnostics.Process.ExitCode%2A> (geralmente um zero para êxito ou um código de erro diferente de zero) e o <xref:System.Diagnostics.Process.ExitTime%2A>. Identificadores são um recurso extremamente valioso, portanto vazando identificadores é mais virulentos de vazamento de memória.  
  
> [!NOTE]
>  Esta classe contém uma demanda de link e uma demanda de herança no nível de classe que se aplica a todos os membros. Um <xref:System.Security.SecurityException> é lançado quando o chamador imediato ou a classe derivada não tem permissão de confiança total. Para obter detalhes sobre demandas de segurança, consulte [demandas de Link](~/docs/framework/misc/link-demands.md).  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Notas  
 No .NET Framework, o <xref:System.Diagnostics.Process> classe por padrão, usa <xref:System.Console> codificações, que normalmente são codificações de página, para os fluxos de entrada, saída e erro de código. Por exemplo de código, em sistemas cuja cultura for inglês (Estados Unidos), a página de código 437 é a codificação padrão para o <xref:System.Console> classe. No entanto, [!INCLUDE[net_core](~/includes/net-core-md.md)] podem disponibilizar somente um subconjunto limitado dessas codificações. Se esse for o caso, ele usa <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> como a codificação padrão.  
  
 Se um <xref:System.Diagnostics.Process> objeto depende de codificações de página de código específico, você pode ainda disponibilizá-las, fazendo o seguinte *antes de* você chamar qualquer <xref:System.Diagnostics.Process> métodos:  
  
1.  Adicione uma referência ao assembly System.Text.Encoding.CodePages.dll ao seu projeto.  
  
2.  Recuperar o <xref:System.Text.EncodingProvider> objeto o <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> propriedade.  
  
3.  Passe o <xref:System.Text.EncodingProvider> do objeto para o <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> método para fazer as codificações adicionais compatíveis com o provedor de codificação disponível.  
  
 O <xref:System.Diagnostics.Process> classe, em seguida, usará automaticamente a codificação de sistema padrão em vez de UTF8, desde que você registrou o provedor de codificação antes de chamar qualquer <xref:System.Diagnostics.Process> métodos.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância da <xref:System.Diagnostics.Process> classe iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 O exemplo a seguir usa o <xref:System.Diagnostics.Process> da classe em si e estático <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 O seguinte F# exemplo define uma `runProc` função que inicia um processo de captura todas as informações de erro e de saída e registra o número de milissegundos que o processo foi executado.  O `runProc` função tem três parâmetros: o nome do aplicativo para iniciar, os argumentos para fornecer ao aplicativo e o diretório inicial.  
  
 [!code-fsharp[System.Diagnostics.Process#1](~/samples/snippets/fsharp/VS_Snippets_CLR_System/system.diagnostics.process/fs/Start1.fs#1)]  
  
 O código para o `runProc` função foi escrita por [ImaginaryDevelopment](http://fssnip.net/authors/ImaginaryDevelopment) e está disponível sob o [licença pública da Microsoft](https://opensource.org/licenses/ms-pl).  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Esta classe não pode ser usada pelo código parcialmente confiável.</permission>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">para confiança total de herdeiros. Esta classe não pode ser herdada pelo código parcialmente confiável.</permission>
    <altmember cref="M:System.Diagnostics.Process.Start" />
    <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
    <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
    <altmember cref="M:System.Diagnostics.Process.Kill" />
    <altmember cref="T:System.Diagnostics.ProcessThread" />
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/windowsdesktop/Using-the-NET-Process-Class-d70597ef">Usando a classe de processo do .NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Process ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Process();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Diagnostics.Process" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se você não especificar o <xref:System.Diagnostics.Process.MachineName%2A> propriedade, o padrão é o computador local, (".").  
  
 Você tem duas opções para associar um novo <xref:System.Diagnostics.Process> componente com um processo no computador. A primeira opção é usar o construtor para criar o <xref:System.Diagnostics.Process> componente, definir os membros adequados dos <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chame <xref:System.Diagnostics.Process.Start%2A> para associar o <xref:System.Diagnostics.Process> com um novo processo de sistema. A segunda opção é associar o <xref:System.Diagnostics.Process> com um processo de sistema em execução usando <xref:System.Diagnostics.Process.GetProcessById%2A> ou uma da <xref:System.Diagnostics.Process.GetProcesses%2A> valores de retorno.  
  
 Se você usar um `static` sobrecarga da <xref:System.Diagnostics.Process.Start%2A> método para iniciar um novo processo de sistema, o método cria um novo <xref:System.Diagnostics.Process> componente e a associa com o processo.  
  
 Quando o <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> estiver definida como seu valor padrão, `true`, você pode iniciar aplicativos e documentos de uma maneira que é semelhante a usar o `Run` caixa de diálogo do Windows `Start` menu. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> é `false`, você pode iniciar somente os executáveis.  
  
 Qualquer arquivo executável que você pode chamar a partir da linha de comando pode ser iniciado em uma das duas maneiras: definindo os membros adequados dos <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar o <xref:System.Diagnostics.Process.Start%2A> método sem parâmetros, ou passando o parâmetro apropriado para o `static` <xref:System.Diagnostics.Process.Start%2A> membro.  
  
 Você pode criar uma <xref:System.Diagnostics.Process> componente usando o construtor, um dos estático <xref:System.Diagnostics.Process.Start%2A> sobrecargas ou qualquer um dos <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcesses%2A>, ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> métodos. Depois de você ter feito isso, você tem um modo de exibição para o processo associado. Isso não é uma exibição dinâmica que atualiza a mesmo automaticamente quando as propriedades de processo foram alteradas na memória. Em vez disso, você deve chamar <xref:System.Diagnostics.Process.Refresh%2A> para o componente atualizar o <xref:System.Diagnostics.Process> informações de propriedade em seu aplicativo.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="BasePriority">
      <MemberSignature Language="C#" Value="public int BasePriority { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BasePriority" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.BasePriority" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BasePriority As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BasePriority { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BasePriority : int" Usage="System.Diagnostics.Process.BasePriority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Base process priority.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessBasePriority")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a prioridade base do processo associado.</summary>
        <value>A prioridade base, que é calculada de <see cref="P:System.Diagnostics.Process.PriorityClass" /> do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.BasePriority%2A> do processo é a prioridade de partida para threads criados dentro do processo associado. Você pode exibir informações sobre a prioridade base por meio do contador de Base de prioridade do Monitor do sistema.  
  
 Com base no tempo decorrida ou outras aumenta, o sistema operacional pode alterar a prioridade básica quando um processo deve ser colocado à frente dos outros.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba a partida prioridade atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> para definir a prioridade do processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade. O <xref:System.Diagnostics.Process.BasePriority%2A> pode ser exibido usando o Monitor do sistema, enquanto o <xref:System.Diagnostics.Process.PriorityClass%2A> não é. Tanto a <xref:System.Diagnostics.Process.BasePriority%2A> e o <xref:System.Diagnostics.Process.PriorityClass%2A> podem ser exibidas programaticamente. A tabela a seguir mostra a relação entre <xref:System.Diagnostics.Process.BasePriority%2A> valores e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo foi encerrado.  
  
- ou - 
O processo não foi iniciado, portanto, não há ID de processo.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="T:System.Diagnostics.ProcessPriorityClass" />
        <altmember cref="T:System.Diagnostics.ThreadPriorityLevel" />
      </Docs>
    </Member>
    <Member MemberName="BeginErrorReadLine">
      <MemberSignature Language="C#" Value="public void BeginErrorReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginErrorReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginErrorReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginErrorReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginErrorReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginErrorReadLine : unit -&gt; unit" Usage="process.BeginErrorReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia as operações de leitura assíncronas no fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Eles síncrona ler operações não forem concluídas até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> transmitir ou fecha o fluxo.  
  
 Em contraste, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operações de leitura assíncrona de início no <xref:System.Diagnostics.Process.StandardError%2A> stream. Esse método permite que o manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A> como `true`.  
  
3.  Adicionar o manipulador de eventos a <xref:System.Diagnostics.Process.ErrorDataReceived> eventos. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chame <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas no <xref:System.Diagnostics.Process.StandardError%2A>.  
  
 Quando iniciar as operações de leitura assíncrona, o manipulador de eventos é chamado sempre que associado <xref:System.Diagnostics.Process> escreve uma linha de texto para seu <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelErrorRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Após o cancelamento, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Você não pode misturar operações síncronas e assíncronas de leitura em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Por exemplo, não seguem <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> sobre o <xref:System.Diagnostics.Process.StandardError%2A> stream, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes em modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo para saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados no console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> é <see langword="false" />.  
  
- ou - 
Uma operação de leitura assíncrona já está em andamento no fluxo <see cref="P:System.Diagnostics.Process.StandardError" />.  
  
- ou - 
O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> foi usado por uma operação de leitura síncrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
      </Docs>
    </Member>
    <Member MemberName="BeginOutputReadLine">
      <MemberSignature Language="C#" Value="public void BeginOutputReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginOutputReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.BeginOutputReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginOutputReadLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginOutputReadLine();" />
      <MemberSignature Language="F#" Value="member this.BeginOutputReadLine : unit -&gt; unit" Usage="process.BeginOutputReadLine " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia as operações de leitura assíncronas no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado do aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Eles síncrona ler operações não forem concluídas até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir ou fecha o fluxo.  
  
 Em contraste, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operações de leitura assíncrona de início no <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Siga estas etapas para executar operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A> para um <xref:System.Diagnostics.Process> :  
  
1.  Defina <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> como `false`.  
  
2.  Defina <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A> como `true`.  
  
3.  Adicionar o manipulador de eventos a <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos deve corresponder a <xref:System.Diagnostics.DataReceivedEventHandler?displayProperty=nameWithType> assinatura do delegado.  
  
4.  Iniciar o <xref:System.Diagnostics.Process>.  
  
5.  Chame <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para o <xref:System.Diagnostics.Process>. Essa chamada inicia as operações de leitura assíncronas no <xref:System.Diagnostics.Process.StandardOutput%2A>.  
  
 Quando iniciar as operações de leitura assíncrona, o manipulador de eventos é chamado sempre que associado <xref:System.Diagnostics.Process> escreve uma linha de texto para seu <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
 Você pode cancelar uma operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.CancelOutputRead%2A>. A operação de leitura pode ser cancelada pelo chamador ou pelo manipulador de eventos. Após o cancelamento, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente para retomar as operações de leitura assíncronas.  
  
> [!NOTE]
>  Você não pode misturar operações síncronas e assíncronas de leitura em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Por exemplo, não seguem <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> sobre o <xref:System.Diagnostics.Process.StandardOutput%2A> stream, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes em modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas em redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `sort` comando. O `sort` comando é um aplicativo de console que lê e classifica a entrada de texto.  
  
 O exemplo cria um delegado de evento para o `SortOutputHandler` manipulador de eventos e a associa com o <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto de redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e escreve o texto na tela.  
  
 [!code-cpp[Process_AsyncStreams#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/sort_async.cpp#1)]
 [!code-csharp[Process_AsyncStreams#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/sort_async.cs#1)]
 [!code-vb[Process_AsyncStreams#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/sort_async.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> é <see langword="false" />.  
  
- ou - 
Uma operação de leitura assíncrona já está em andamento no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" />.  
  
- ou - 
O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> foi usado por uma operação de leitura síncrona.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
      </Docs>
    </Member>
    <Member MemberName="CancelErrorRead">
      <MemberSignature Language="C#" Value="public void CancelErrorRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelErrorRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelErrorRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelErrorRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelErrorRead();" />
      <MemberSignature Language="F#" Value="member this.CancelErrorRead : unit -&gt; unit" Usage="process.CancelErrorRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela a operação de leitura assíncrona no fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado de um aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> inicia uma operação de leitura assíncrona no <xref:System.Diagnostics.Process.StandardError%2A> stream. <xref:System.Diagnostics.Process.CancelErrorRead%2A> termina a operação de leitura assíncrona.  
  
 Após o cancelamento, você pode retomar a operação de leitura assíncrona chamando <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelErrorRead%2A>, todas as operações de leitura de em andamento <xref:System.Diagnostics.Process.StandardError%2A> forem concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardError%2A> serão perdidas. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>assíncrona retomar operações de leitura. Se você quiser alterar o manipulador de eventos antes de retomar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar o novo manipulador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(ErrorHandler1)   
// has executed a CancelErrorRead.  
  
// Remove the prior event handler.  
process.ErrorDataReceived -=   
    new DataReceivedEventHandler(ErrorHandler1);  
  
// Register a new event handler.  
process.ErrorDataReceived +=   
    new DataReceivedEventHandler(ErrorHandler2);  
  
// Call the corresponding BeginErrorReadLine.  
process.BeginErrorReadLine();  
```  
  
> [!NOTE]
>  Você não pode misturar as operações de leitura síncronas e assíncronas em redirecionado <xref:System.Diagnostics.Process.StandardError%2A> stream. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Se você cancelar uma operação de leitura assíncrona na <xref:System.Diagnostics.Process.StandardError%2A> e, em seguida, precisa ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelErrorRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardError%2A> tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de erro e de saída são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas são canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> não está habilitado para operações de leitura assíncronas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="E:System.Diagnostics.Process.ErrorDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CancelOutputRead">
      <MemberSignature Language="C#" Value="public void CancelOutputRead ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelOutputRead() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CancelOutputRead" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelOutputRead ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelOutputRead();" />
      <MemberSignature Language="F#" Value="member this.CancelOutputRead : unit -&gt; unit" Usage="process.CancelOutputRead " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cancela a operação de leitura assíncrona no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado de um aplicativo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> inicia uma operação de leitura assíncrona no <xref:System.Diagnostics.Process.StandardOutput%2A> stream. <xref:System.Diagnostics.Process.CancelOutputRead%2A> termina a operação de leitura assíncrona.  
  
 Após o cancelamento, você poderá retomar as operações de leitura assíncronas chamando <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> novamente.  
  
 Quando você chama <xref:System.Diagnostics.Process.CancelOutputRead%2A>, todas as operações de leitura de em andamento <xref:System.Diagnostics.Process.StandardOutput%2A> forem concluídas e, em seguida, o manipulador de eventos está desabilitado. Todos os redirecionado ainda mais a saída para <xref:System.Diagnostics.Process.StandardOutput%2A> é salvo em um buffer. Se você habilitar novamente o manipulador de eventos com uma chamada para <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>, a saída salva é enviada para o manipulador de eventos e retomar operações de leitura assíncronas. Se você quiser alterar o manipulador de eventos antes de retomar as operações de leitura assíncronas, você deve remover o manipulador de eventos existente antes de adicionar o novo manipulador de eventos:  
  
```csharp  
// At this point the DataReceivedEventHandler(OutputHandler1)   
// has executed a CancelOutputRead.  
  
// Remove the prior event handler.  
process.OutputDataReceived -=   
    new DataReceivedEventHandler(OutputHandler1);  
  
// Register a new event handler.  
process.OutputDataReceived +=   
    new DataReceivedEventHandler(OutputHandler2);  
  
// Call the corresponding BeginOutputReadLine.  
process.BeginOutputReadLine();  
```  
  
> [!NOTE]
>  Você não pode misturar as operações de leitura síncronas e assíncronas em redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Se você cancelar uma operação de leitura assíncrona na <xref:System.Diagnostics.Process.StandardOutput%2A> e, em seguida, precisa ler do fluxo novamente, você deve usar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> para retomar as operações de leitura assíncronas. Não siga <xref:System.Diagnostics.Process.CancelOutputRead%2A> com uma chamada para o síncrona ler métodos de <xref:System.Diagnostics.Process.StandardOutput%2A> tais como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, ou <xref:System.IO.StreamReader.ReadToEnd%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia o `nmake` comando com o usuário os argumentos fornecidos. Os fluxos de erro e de saída são de leitura assíncrona. as linhas de texto coletados são exibidas no console, bem como gravadas em um arquivo de log. Se a saída do comando excede um número especificado de linhas, as operações de leitura assíncronas são canceladas.  
  
 [!code-cpp[Process_AsyncStreams#3](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/nmake_async.cpp#3)]
 [!code-csharp[Process_AsyncStreams#3](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/nmake_async.cs#3)]
 [!code-vb[Process_AsyncStreams#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/nmake_async.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> não está habilitado para operações de leitura assíncronas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="E:System.Diagnostics.Process.OutputDataReceived" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="process.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera todos os recursos associados a esse componente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Close%2A> método faz com que o processo para interromper a espera para sair se estava esperando, fecha o identificador de processo e limpa as propriedades específicas de processo. <xref:System.Diagnostics.Process.Close%2A> Não feche os leitores de erro, entrada e saída padrão e gravadores caso estão sendo referenciados externamente.  
  
> [!NOTE]
>  O método <xref:System.Diagnostics.Process.Dispose%2A> chama <xref:System.Diagnostics.Process.Close%2A>. Colocar o <xref:System.Diagnostics.Process> do objeto em um `using` bloco descarta os recursos sem a necessidade de chamar <xref:System.Diagnostics.Process.Close%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Ele então recupera o uso de memória física do processo associado em intervalos de 2 segundos para um máximo de 10 segundos. O exemplo detecta se o processo será encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="CloseMainWindow">
      <MemberSignature Language="C#" Value="public bool CloseMainWindow ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CloseMainWindow() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.CloseMainWindow" />
      <MemberSignature Language="VB.NET" Value="Public Function CloseMainWindow () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CloseMainWindow();" />
      <MemberSignature Language="F#" Value="member this.CloseMainWindow : unit -&gt; bool" Usage="process.CloseMainWindow " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Fecha um processo que tem uma interface do usuário enviando uma mensagem de fechamento à janela principal.</summary>
        <returns><see langword="true" /> se a mensagem de fechamento tiver sido enviada com êxito; <see langword="false" /> se o processo associado não tiver uma janela principal ou se a janela principal estiver desabilitada (por exemplo, se uma caixa de diálogo modal estiver sendo mostrada).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um processo está em execução, seu loop de mensagem está em um estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagem para o aplicativo. A solicitação para encerrar o processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode solicitar a verificação de usuário antes de encerrar ou ele poderá recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário de fechar a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para encerrar o processo, fechando a janela principal não força o aplicativo para sair imediatamente.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> faz com que um encerramento anormal do processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar o processo. <xref:System.Diagnostics.Process.Kill%2A> é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Ele então recupera o uso de memória física do processo associado intervalos de 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo será encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo já terminou.  
  
- ou - 
Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="process.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="override this.Dispose : bool -&gt; unit" Usage="process.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" /> para liberar recursos gerenciados e não gerenciados; <see langword="false" /> para liberar apenas recursos não gerenciados.</param>
        <summary>Libere todos os recursos usados por esse processo.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableRaisingEvents">
      <MemberSignature Language="C#" Value="public bool EnableRaisingEvents { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableRaisingEvents" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableRaisingEvents As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableRaisingEvents { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableRaisingEvents : bool with get, set" Usage="System.Diagnostics.Process.EnableRaisingEvents" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Whether the process component should watch for the associated process to exit, and raise the Exited event.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessEnableRaisingEvents")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define se o evento <see cref="E:System.Diagnostics.Process.Exited" /> deve ser gerado quando o processo é encerrado.</summary>
        <value><see langword="true" /> se o evento <see cref="E:System.Diagnostics.Process.Exited" /> precisar ser gerado quando o processo associado for terminado (por meio de uma saída ou uma chamada a <see cref="M:System.Diagnostics.Process.Kill" />); caso contrário, <see langword="false" />. O padrão é <see langword="false" />. Observe que o <see cref="E:System.Diagnostics.Process.Exited" /> é gerado, mesmo se o valor da <see cref="P:System.Diagnostics.Process.EnableRaisingEvents" /> é <see langword="false" /> quando o processo será encerrado durante ou antes que o usuário executa um <see cref="P:System.Diagnostics.Process.HasExited" /> verificar.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade sugere se o componente deve ser notificado quando o sistema operacional encerrou um processo. O <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> no processamento assíncrono, a propriedade é usada para notificar o aplicativo que um processo foi encerrado. Para forçar o aplicativo a aguardar de forma síncrona um evento de saída (o que interrompe o processamento do aplicativo até que ocorreu o evento de saída), use o <xref:System.Diagnostics.Process.WaitForExit%2A> método.

> [!NOTE]
> Se você estiver usando o Visual Studio e clique duas vezes em uma <xref:System.Diagnostics.Process> componente em seu projeto, um <xref:System.Diagnostics.Process.Exited> delegado do evento e o manipulador de eventos são gerados automaticamente. Conjuntos de códigos adicionais a <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade para `false`. Você deve alterar essa propriedade para `true` seu manipulador de eventos ser executado quando o processo associado é encerrado.

Se o componente <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> valor é `true`, ou quando <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é `false` e um <xref:System.Diagnostics.Process.HasExited%2A> seleção é invocada pelo componente, o componente pode acessar as informações administrativas para o processo associado, que permanece armazenados pelo sistema operacional. Essas informações incluem o <xref:System.Diagnostics.Process.ExitTime%2A> e o <xref:System.Diagnostics.Process.ExitCode%2A>.

Depois que o processo associado é encerrado, o <xref:System.Diagnostics.Process.Handle%2A> do componente não aponta mais para um recurso de processo existente. Em vez disso, ele só pode ser usado para acessar as informações do sistema operacional sobre o recurso de processo. O sistema operacional está ciente de que há identificadores para processos encerrados que ainda não foi lançados pela <xref:System.Diagnostics.Process> componentes, para que ele mantém os <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória.

Há um custo associado ao assistir a um processo seja encerrado. Se <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> está `true`, o <xref:System.Diagnostics.Process.Exited> evento é gerado quando o processo associado seja encerrado. Os procedimentos para o <xref:System.Diagnostics.Process.Exited> executado nesse horário do evento.

Às vezes, seu aplicativo inicia um processo, mas não requer a notificação de seu fechamento. Por exemplo, seu aplicativo pode iniciar o bloco de notas para permitir que o usuário executar a edição de texto, mas nenhuma outra fazer uso do aplicativo bloco de notas. Você pode escolher evitar a notificação quando o processo é encerrado porque ele não é relevante para a operação contínua de seu aplicativo. Definindo <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> para `false` pode salvar os recursos do sistema.

## Examples  
O exemplo de código a seguir cria um processo que imprime um arquivo. Ele define a <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade para fazer com que o processo gerar o <xref:System.Diagnostics.Process.Exited> eventos quando ele é encerrado. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.

[!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]   
[!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]   
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
      </Docs>
    </Member>
    <Member MemberName="EnterDebugMode">
      <MemberSignature Language="C#" Value="public static void EnterDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EnterDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.EnterDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EnterDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EnterDebugMode();" />
      <MemberSignature Language="F#" Value="static member EnterDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.EnterDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Coloca um componente <see cref="T:System.Diagnostics.Process" /> no estado para interagir com os processos do sistema operacional executados em um modo especial, habilitando a propriedade nativa <see langword="SeDebugPrivilege" /> no thread atual.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos de sistema operacional executado em um modo especial. A tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você tenha chamado <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.LeaveDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="ErrorDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler ErrorDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler ErrorDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.ErrorDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ErrorDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ ErrorDataReceived;" />
      <MemberSignature Language="F#" Value="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.ErrorDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um aplicativo realiza gravação em seu fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> redirecionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ErrorDataReceived> evento indica que o processo associado tiver gravados redirecionado <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
 O evento ocorre apenas durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardError%2A>. Para iniciar operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardError%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos a <xref:System.Diagnostics.Process.ErrorDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginErrorReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.ErrorDataReceived> sinais de eventos sempre que o processo grava uma linha para redirecionado <xref:System.Diagnostics.Process.StandardError%2A> transmitir, até que o processo é encerrado ou chame <xref:System.Diagnostics.Process.CancelErrorRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit> método para garantir que o buffer de saída foi liberado. Observe que especificar um tempo limite usando o <xref:System.Diagnostics.Process.WaitForExit(System.Int32)> sobrecarga faz *não* Verifique se o buffer de saída foi liberado.
  
   
  
## Examples  
 O exemplo a seguir usa o `net view` comando para listar os recursos de rede disponíveis em um computador remoto. O usuário fornece o nome do computador de destino como um argumento de linha de comando. O usuário também pode fornecer um nome de arquivo para saída de erro. O exemplo coleta a saída do comando net, aguarda a conclusão do processo e, em seguida, grava a saída de resultados no console. Se o usuário fornece o arquivo de erro opcional, o exemplo grava erros no arquivo.  
  
 [!code-cpp[Process_AsyncStreams#2](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/net_async.cpp#2)]
 [!code-csharp[Process_AsyncStreams#2](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/net_async.cs#2)]
 [!code-vb[Process_AsyncStreams#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/net_async.vb#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="M:System.Diagnostics.Process.BeginErrorReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelErrorRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public int ExitCode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ExitCode { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int" Usage="System.Diagnostics.Process.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The value returned from the associated process when it terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitCode")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o valor especificado pelo processo associado quando ele foi finalizado.</summary>
        <value>O código especificado pelo processo associado quando ele foi finalizado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.ExitCode%2A> para obter o status que o processo do sistema retornado quando ele foi encerrado. Você pode usar o código de saída muito, como um número inteiro retornar o valor de uma `main()` procedimento.  
  
 O <xref:System.Diagnostics.Process.ExitCode%2A> valor para um processo reflete a convenção específica implementada pelo desenvolvedor do aplicativo para que o processo. Se você usar o valor do código de saída para tomar decisões em seu código, certifique-se de que você sabe que a convenção de código de saída usada pelo processo de aplicativo.  
  
 Os desenvolvedores geralmente indicam uma saída com êxito por um <xref:System.Diagnostics.Process.ExitCode%2A> valor de zero e designar erros por valores diferentes de zero que o método de chamada pode usar para identificar a causa de um encerramento anormal do processo. Não é necessário seguir estas diretrizes, mas eles são a convenção.  
  
 Se você tentar obter o <xref:System.Diagnostics.Process.ExitCode%2A> antes que o processo foi encerrado, a tentativa de gera uma exceção. Examinar o <xref:System.Diagnostics.Process.HasExited%2A> propriedade primeiro para verificar se o processo associado foi encerrado.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncronos, é possível que o processamento de saída será não tenha concluído quando <xref:System.Diagnostics.Process.HasExited%2A> retorna `true`. Para garantir que a manipulação assíncrona de eventos foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
 Você pode usar o <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou o <xref:System.Diagnostics.Process.Kill%2A> método para fazer com que um processo associado seja encerrado.  
  
 Há duas maneiras de ser notificado quando o processo associado sair: forma síncrona e assíncrona. Notificação síncrona se baseia em chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para pausar o processamento de seu aplicativo até que o componente associado seja encerrado. Notificação assíncrona depende o <xref:System.Diagnostics.Process.Exited> eventos. Ao usar a notificação assíncrona, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definida como `true` para o <xref:System.Diagnostics.Process> componente para receber a notificação de que o processo foi encerrado.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não foi encerrado.  
  
- ou - 
O processo <see cref="P:System.Diagnostics.Process.Handle" /> não é válido.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ExitCode" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
      </Docs>
    </Member>
    <Member MemberName="Exited">
      <MemberSignature Language="C#" Value="public event EventHandler Exited;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Exited" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.Exited" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Exited As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Exited;" />
      <MemberSignature Language="F#" Value="member this.Exited : EventHandler " Usage="member this.Exited : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Category("Behavior")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("If the WatchForExit property is set to true, then this event is raised when the associated process exits.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExited")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre quando um processo é fechado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.Exited> evento indica que o processo associado foi encerrado. Essa ocorrência significa que o processo encerrado (anulada) ou fechado com êxito. Esse evento pode ocorrer somente se o valor da <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> é de propriedade `true`.  
  
 Há duas maneiras de ser notificado quando o processo associado sair: forma síncrona e assíncrona. Notificação de síncrona significa chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para bloquear o thread atual até que o processo seja encerrado. Notificação assíncrona usa o <xref:System.Diagnostics.Process.Exited> evento, que permite que o thread de chamada continuar a execução nesse meio tempo. No último caso, <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> deve ser definida como `true` para o aplicativo de chamada receber o evento encerrado.  
  
 Quando o sistema operacional é desligado por um processo, ele notifica todos os outros processos que foram registrados manipuladores para o evento encerrado. Neste momento, o identificador do processo que acabou de sair pode ser usado para acessar algumas propriedades como <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.HasExited%2A> que o sistema operacional mantém até que ele libera esse identificador completamente.  
  
> [!NOTE]
>  Mesmo se você tiver um identificador para um processo encerrado, você não pode chamar <xref:System.Diagnostics.Process.Start%2A> novamente para reconectar-se para o mesmo processo. Chamando <xref:System.Diagnostics.Process.Start%2A> automaticamente libera o processo associado e se conecta a um processo com o mesmo arquivo, mas um totalmente novo <xref:System.Diagnostics.Process.Handle%2A>.  
  
 Para obter mais informações sobre o uso do <xref:System.Diagnostics.Process.Exited> eventos em aplicativos Windows Forms, consulte o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. Ele gera o <xref:System.Diagnostics.Process.Exited> evento quando o processo é encerrado porque o <xref:System.Diagnostics.Process.EnableRaisingEvents%2A> propriedade foi definida quando o processo foi criado. O <xref:System.Diagnostics.Process.Exited> manipulador de eventos exibe informações de processo.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExitTime">
      <MemberSignature Language="C#" Value="public DateTime ExitTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExitTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ExitTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExitTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExitTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.ExitTime : DateTime" Usage="System.Diagnostics.Process.ExitTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time that the associated process exited.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessExitTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora em que o processo associado foi encerrado.</summary>
        <value>Um <see cref="T:System.DateTime" /> que indica quando o processo associado foi encerrado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se o processo não tiver sido encerrado, a tentativa de recuperar o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade gera uma exceção. Use <xref:System.Diagnostics.Process.HasExited%2A> antes de obter o <xref:System.Diagnostics.Process.ExitTime%2A> propriedade para determinar se o processo associado foi encerrado.  
  
   
  
## Examples  
 O exemplo de código a seguir cria um processo que imprime um arquivo. Aciona o processo de <xref:System.Diagnostics.Process.Exited> eventos quando ele é encerrado e o manipulador de eventos exibe o <xref:System.Diagnostics.Process.ExitTime%2A> processam de propriedade e outras informações.  
  
 [!code-csharp[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/CS/processexitedevent.cs#1)]
 [!code-vb[System.Diagnostics.Process.EnableExited#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.EnableExited/VB/processexitedevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ExitTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcess">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetCurrentProcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetCurrentProcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetCurrentProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcess () As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetCurrentProcess();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcess : unit -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetCurrentProcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtém um novo componente <see cref="T:System.Diagnostics.Process" /> e o associa ao processo ativo no momento.</summary>
        <returns>Um novo componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo que está executando o aplicativo de chamada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> da instância e associá-la com o recurso de processo no computador local.  
  
 Como a semelhante <xref:System.Diagnostics.Process.GetProcessById%2A>, <xref:System.Diagnostics.Process.GetProcessesByName%2A>, e <xref:System.Diagnostics.Process.GetProcesses%2A> métodos <xref:System.Diagnostics.Process.GetCurrentProcess%2A> associa um recurso existente com um novo <xref:System.Diagnostics.Process> componente.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessById">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria um novo componente <see cref="T:System.Diagnostics.Process" /> e associa-o ao recurso de processo existente que você especificar.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById processId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="processId">O identificador exclusivo do sistema de um recurso de processo.</param>
        <summary>Retorna um novo componente <see cref="T:System.Diagnostics.Process" />, tendo em conta o identificador de um processo no computador local.</summary>
        <returns>Um componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso de processo local identificado pelo parâmetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo no computador local. O recurso de processo já deve existir no computador, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> não cria um recurso do sistema, mas em vez disso, associa um recurso a um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> podem ser recuperados apenas para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%29> Retorna um processo no máximo. Se você quiser obter todos os processos em execução um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se vários processos existirem no computador que executa o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos por sua vez para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
 O `processId` parâmetro é um <xref:System.Int32> (um inteiro 32 bits com sinal), embora a API básica do Windows usa um `DWORD` (um inteiro de 32 bits sem sinal) para APIs semelhantes. Isso é por razões históricas.
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O processo especificado pelo parâmetro <paramref name="processId" /> não está em execução. O identificador pode ter expirado.</exception>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado por esse objeto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessById">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process GetProcessById (int processId, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process GetProcessById(int32 processId, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessById (processId As Integer, machineName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ GetProcessById(int processId, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessById : int * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.GetProcessById (processId, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processId" Type="System.Int32" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processId">O identificador exclusivo do sistema de um recurso de processo.</param>
        <param name="machineName">O nome de um computador na rede.</param>
        <summary>Retorna um novo componente <see cref="T:System.Diagnostics.Process" />, dado um identificador de processo e o nome de um computador na rede.</summary>
        <returns>Um componente <see cref="T:System.Diagnostics.Process" /> associado ao recurso de processo remoto identificado pelo parâmetro <paramref name="processId" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar um novo <xref:System.Diagnostics.Process> componente e associá-lo a um recurso de processo em um computador remoto na rede. O recurso de processo já deve existir no computador especificado, porque <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> não cria um recurso do sistema, mas em vez disso, associa um recurso a um aplicativo gerado <xref:System.Diagnostics.Process> componente. Um processo <xref:System.Diagnostics.Process.Id%2A> podem ser recuperados apenas para um processo que está sendo executado no computador. Depois que o processo termina, <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> lança uma exceção se você passar um identificador expirado.  
  
 Em qualquer computador em particular, o identificador de um processo é exclusivo. <xref:System.Diagnostics.Process.GetProcessById%28System.Int32%2CSystem.String%29> Retorna um processo no máximo. Se você quiser obter todos os processos em execução um aplicativo específico, use <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29>. Se vários processos existirem no computador que executa o aplicativo especificado, <xref:System.Diagnostics.Process.GetProcessesByName%28System.String%29> retorna uma matriz que contém todos os processos associados. Você pode consultar cada um desses processos por sua vez para seu identificador. O identificador de processo pode ser exibido no `Processes` painel do Gerenciador de tarefas do Windows. O `PID` coluna exibe o identificador do processo que é atribuído a um processo.  
  
 Se você não especificar um `machineName`, será usado o computador local. Como alternativa, você pode especificar o computador local, definindo `machineName` para o valor "." ou uma cadeia de caracteres vazia ("").  
  
 O `processId` parâmetro é um <xref:System.Int32> (um inteiro 32 bits com sinal), embora a API básica do Windows usa um `DWORD` (um inteiro de 32 bits sem sinal) para APIs semelhantes. Isso é por razões históricas.   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O processo especificado pelo parâmetro <paramref name="processId" /> não está em execução. O identificador pode ter expirado.  
  
- ou - 
A sintaxe do parâmetro <paramref name="machineName" /> é inválida. O nome pode ter tamanho zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado por esse objeto.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcesses">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e associa-os a recursos de processo existentes.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses () As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses();" />
      <MemberSignature Language="F#" Value="static member GetProcesses : unit -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Cria um novo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de processo no computador local.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa todos os recursos de processo sendo executados no computador local.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-los com todos os recursos de processo no computador local. Os recursos do processo já devem existir no computador local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Como o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos do processo associado compartilham o arquivo executável que você passa para o método.  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados dentro da mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identifica esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcesses">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcesses (string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcesses(string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcesses(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcesses (machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcesses(System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcesses : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcesses machineName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("There is no support for retrieving process information from a remote machine")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="machineName">O computador por meio do qual deve ser lida a lista de processos.</param>
        <summary>Cria um novo componente <see cref="T:System.Diagnostics.Process" /> para cada recurso de processo no computador especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa todos os recursos de processo sendo executados no computador especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-los com todos os recursos de processo no computador (normalmente, remoto) especificado. Os recursos do processo já devem existir no computador local, porque <xref:System.Diagnostics.Process.GetProcesses%2A> não cria recursos do sistema, mas em vez disso, associa recursos gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Como o próprio sistema operacional está executando processos em segundo plano, essa matriz nunca está vazia.  
  
 Se você não quiser recuperar todos os processos em execução no computador, você pode restringir o número de usando o <xref:System.Diagnostics.Process.GetProcessById%2A> ou <xref:System.Diagnostics.Process.GetProcessesByName%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> cria um <xref:System.Diagnostics.Process> componente que está associado com o processo identificado no sistema pelo identificador de processo que você passa para o método. <xref:System.Diagnostics.Process.GetProcessesByName%2A> cria uma matriz de <xref:System.Diagnostics.Process> componentes cujos recursos do processo associado compartilham o arquivo executável que você passa para o método.  
  
 Essa sobrecarga da <xref:System.Diagnostics.Process.GetProcesses%2A> método geralmente é usado para recuperar a lista de recursos de processo em execução em um computador remoto na rede, mas você pode especificar o computador local, passando ".".  
  
> [!NOTE]
>  Vários serviços do Windows podem ser carregados dentro da mesma instância do processo de Host de serviço (svchost.exe). GetProcesses não identifica esses serviços individuais; Para fazer isso, consulte <xref:System.ServiceProcess.ServiceController.GetServices%2A>.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="machineName" /> é inválida. Ele pode ter comprimento zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos.</exception>
        <exception cref="T:System.InvalidOperationException">Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um problema ao acessar uma API do sistema subjacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProcessesByName">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e associa-os aos recursos de processo existentes que compartilham o nome do processo especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName processName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">O nome amigável do processo.</param>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e os associa a todos os recursos do processo no computador local que compartilham o nome do processo especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa os recursos do processo que executam o aplicativo ou arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo que estiver executando o mesmo arquivo executável no computador local. Os recursos do processo já devem existir no computador, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável que não está atualmente em execução no computador local, portanto, a matriz em que o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A> é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável como o `processName` parâmetro para desligar todas as instâncias em execução desse arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo do sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas à API standard, você pode consultar cada um desses processos por sua vez para seu identificador. Você não pode acessar os recursos de processo por meio de apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos do processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="GetProcessesByName">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process[] GetProcessesByName (string processName, string machineName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process[] GetProcessesByName(string processName, string machineName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.GetProcessesByName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetProcessesByName (processName As String, machineName As String) As Process()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::Diagnostics::Process ^&gt; ^ GetProcessesByName(System::String ^ processName, System::String ^ machineName);" />
      <MemberSignature Language="F#" Value="static member GetProcessesByName : string * string -&gt; System.Diagnostics.Process[]" Usage="System.Diagnostics.Process.GetProcessesByName (processName, machineName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="processName" Type="System.String" />
        <Parameter Name="machineName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="processName">O nome amigável do processo.</param>
        <param name="machineName">O nome de um computador na rede.</param>
        <summary>Cria uma matriz de novos componentes <see cref="T:System.Diagnostics.Process" /> e os associa a todos os recursos do processo em um computador remoto que compartilham o nome do processo especificado.</summary>
        <returns>Uma matriz do tipo <see cref="T:System.Diagnostics.Process" /> que representa os recursos do processo que executam o aplicativo ou arquivo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use esse método para criar uma matriz de novos <xref:System.Diagnostics.Process> componentes e associá-las a todos os recursos de processo que estiver executando o mesmo arquivo executável no computador especificado. Os recursos do processo já devem existir no computador, porque <xref:System.Diagnostics.Process.GetProcessesByName%2A> não cria recursos do sistema, mas em vez disso, os associa gerados pelo aplicativo <xref:System.Diagnostics.Process> componentes. Um `processName` pode ser especificado para um arquivo executável que não está atualmente em execução no computador local, portanto, a matriz em que o método retorna pode ser vazia.  
  
 O nome do processo é um nome amigável para o processo, como Outlook, que não inclui a extensão .exe ou o caminho. <xref:System.Diagnostics.Process.GetProcessesByName%2A> é útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável. Por exemplo, você pode passar um nome de arquivo executável como o `processName` parâmetro para desligar todas as instâncias em execução desse arquivo executável.  
  
 Embora um processo <xref:System.Diagnostics.Process.Id%2A> é exclusivo a um recurso de um único processo do sistema, vários processos no computador local podem estar executando o aplicativo especificado pelo `processName` parâmetro. Portanto, <xref:System.Diagnostics.Process.GetProcessById%2A> retorna um processo no máximo, mas <xref:System.Diagnostics.Process.GetProcessesByName%2A> retorna uma matriz que contém todos os processos associados. Se você precisar manipular o processo usando chamadas à API standard, você pode consultar cada um desses processos por sua vez para seu identificador. Você não pode acessar os recursos de processo por meio de apenas o nome do processo, mas, depois de recuperar uma matriz de <xref:System.Diagnostics.Process> componentes que foram associados com os recursos do processo, você pode iniciar, encerrar e manipular os recursos do sistema.  
  
 Você pode usar essa sobrecarga para obter os processos no computador local, bem como em um computador remoto. Use "." para especificar o computador local. Outra sobrecarga existe que usa o computador local por padrão.  
  
 Você pode acessar os processos em computadores remotos somente para exibir informações, como estatísticas sobre os processos. Você não pode fechar, encerrar (usando <xref:System.Diagnostics.Process.Kill%2A>), ou inicie os processos em computadores remotos.  
  
   
  
## Examples  
 O exemplo a seguir recupera informações do processo atual, processos em execução no computador local, todas as instâncias do bloco de notas em execução no computador local e um processo específico no computador local. Ele então recupera informações para os mesmos processos em um computador remoto.  
  
 [!code-cpp[Process.GetProcesses_noexception#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.GetProcesses_noexception/CPP/processstaticget.cpp#1)]
 [!code-csharp[Process.GetProcesses_noexception#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.GetProcesses_noexception/CS/processstaticget.cs#1)]
 [!code-vb[Process.GetProcesses_noexception#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.GetProcesses_noexception/VB/processstaticget.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">A sintaxe do parâmetro <paramref name="machineName" /> é inválida. Ele pode ter comprimento zero (0).</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="machineName" /> é <see langword="null" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma de sistema operacional não dá suporte a esta operação em computadores remotos.</exception>
        <exception cref="T:System.InvalidOperationException">A tentativa de conexão para <paramref name="machineName" /> falhou.

- ou - 
Há problemas ao acessar as APIs de contador de desempenho usadas para obter informações do processo. Essa exceção é específica ao Windows NT, Windows 2000 e Windows XP.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um problema ao acessar uma API do sistema subjacente.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">para chamar código não gerenciado. Enumeração associada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Diagnostics.Process.ProcessName" />
        <altmember cref="P:System.Diagnostics.Process.MachineName" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetCurrentProcess" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Diagnostics.Process.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Returns the native handle for this process.   The handle is only available if the process was started using this component.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo do processo associado.</summary>
        <value>O identificador que o sistema operacional atribuiu ao processo associado quando o processo foi iniciado. O sistema usa esse identificador para manter o controle dos atributos do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um aplicativo pode obter um identificador para um processo que pode ser usado como um parâmetro para muitas funções de informações do processo e controle. Você pode usar esse identificador para inicializar um <xref:System.Threading.WaitHandle> ou chamar métodos nativos com plataforma de invocação.  
  
 Esse identificador de processo é particular a um aplicativo – em outras palavras, processo identificadores não podem ser compartilhados. Um processo também tem um processo <xref:System.Diagnostics.Process.Id%2A> que, ao contrário de <xref:System.Diagnostics.Process.Handle%2A>, é exclusivo e, portanto, válidas em todo o sistema.  
  
 Somente processos iniciados por meio de uma chamada para <xref:System.Diagnostics.Process.Start%2A> defina a <xref:System.Diagnostics.Process.Handle%2A> propriedade correspondente <xref:System.Diagnostics.Process> instâncias.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não foi iniciado ou foi fechado. A propriedade <see cref="P:System.Diagnostics.Process.Handle" /> não pode ser lida porque não há um processo associado a essa instância de <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
A instância de <see cref="T:System.Diagnostics.Process" /> foi anexada a um processo em execução, mas você não tem as permissões necessárias para obter um identificador com direitos de acesso completo.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Handle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Id" />
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.HandleCount" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.Refresh" />
      </Docs>
    </Member>
    <Member MemberName="HandleCount">
      <MemberSignature Language="C#" Value="public int HandleCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 HandleCount" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HandleCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HandleCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int HandleCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.HandleCount : int" Usage="System.Diagnostics.Process.HandleCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Handles for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessHandleCount")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o número de identificadores abertos pelo processo.</summary>
        <value>O número de identificadores do sistema operacional abertos pelo processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Identificadores fornecem uma maneira para um processo para se referir a objetos. Um processo pode obter identificadores de arquivos, recursos, filas de mensagens e muitos outros objetos do sistema operacional. O sistema operacional recupera a memória associada ao processo somente quando a contagem de identificadores é zero.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="HasExited">
      <MemberSignature Language="C#" Value="public bool HasExited { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasExited" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.HasExited" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasExited As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasExited { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasExited : bool" Usage="System.Diagnostics.Process.HasExited" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the associated process has been terminated.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTerminated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se o processo associado foi encerrado.</summary>
        <value><see langword="true" /> se o processo do sistema operacional referenciado pelo componente <see cref="T:System.Diagnostics.Process" /> tiver sido terminado; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um valor de `true` para <xref:System.Diagnostics.Process.HasExited%2A> indica que o processo associado foi encerrado, normalmente ou anormalmente. Você pode solicitar ou forçar o processo associado seja encerrado chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Se um identificador for aberto para o processo, o sistema operacional libera memória do processo quando o processo foi encerrado, mas retém informações administrativas sobre o processo, como o identificador, o código de saída e a hora de saída. Para obter essas informações, você pode usar o <xref:System.Diagnostics.Process.ExitCode%2A> e <xref:System.Diagnostics.Process.ExitTime%2A> propriedades. Essas propriedades são preenchidas automaticamente para processos que foram iniciados por este componente. As informações administrativas são liberadas quando todos os o <xref:System.Diagnostics.Process> componentes que estão associados com o processo do sistema são destruídos e manter nenhum outro identificador para o processo encerrado.  
  
 Um processo pode encerrar independentemente do seu código. Se você iniciou o processo de usar esse componente, o sistema atualiza o valor de <xref:System.Diagnostics.Process.HasExited%2A> automaticamente, mesmo que o processo associado é encerrado de forma independente.  
  
> [!NOTE]
>  Quando a saída padrão foi redirecionada para manipuladores de eventos assíncronos, é possível que o processamento de saída não tenha concluído quando essa propriedade retornará `true`. Para garantir que a manipulação assíncrona de eventos foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro antes de verificar <xref:System.Diagnostics.Process.HasExited%2A>.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Ele então recupera o uso de memória física do processo associado intervalos de 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo será encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há nenhum processo associado ao objeto.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">O código de saída do processo não pôde ser recuperado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.ExitCode" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="M:System.Diagnostics.Process.OnExited" />
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Diagnostics.Process.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The unique identifier for the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador exclusivo para o processo associado.</summary>
        <value>O identificador exclusivo gerado pelo sistema do processo que é referenciado por essa instância de <see cref="T:System.Diagnostics.Process" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O processo de <xref:System.Diagnostics.Process.Id%2A> não é válido se o processo associado não está em execução. Portanto, você deve garantir que o processo está em execução antes de tentar recuperar o <xref:System.Diagnostics.Process.Id%2A> propriedade. Até que o processo termina, o identificador de processo identifica exclusivamente o processo em todo o sistema.  
  
 Você pode se conectar a um processo que está em execução em um computador local ou remoto para uma nova <xref:System.Diagnostics.Process> instância, passando o identificador de processo para o <xref:System.Diagnostics.Process.GetProcessById%2A> método. <xref:System.Diagnostics.Process.GetProcessById%2A> é um `static` método que cria um novo componente e define o <xref:System.Diagnostics.Process.Id%2A> propriedade para o novo <xref:System.Diagnostics.Process> automaticamente da instância.  
  
 Identificadores de processo podem ser reutilizados pelo sistema. O <xref:System.Diagnostics.Process.Id%2A> valor da propriedade é exclusivo somente enquanto o processo associado está em execução. Depois que o processo foi encerrado, o sistema pode reutilizar o <xref:System.Diagnostics.Process.Id%2A> valor da propriedade de um processo não relacionado.  
  
 Como o identificador é exclusivo no sistema, você pode passá-lo para outros threads como uma alternativa ao passar um <xref:System.Diagnostics.Process> instância. Essa ação pode salvar os recursos do sistema ainda garante que o processo é identificado corretamente.  
  
   
  
## Examples  
 O exemplo a seguir demonstra como obter o <xref:System.Diagnostics.Process.Id%2A> para todas as instâncias de um aplicativo em execução. O código cria uma nova instância do bloco de notas, lista todas as instâncias do bloco de notas e, em seguida, permite que o usuário insira o <xref:System.Diagnostics.Process.Id%2A> número para remover uma instância específica.  
  
 [!code-csharp[System.Diagnostics.Process.Id#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Id#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Id/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.Process.Id" /> do processo não foi definida.  
  
- ou - 
Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), defina a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public void Kill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Kill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Kill" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Kill();" />
      <MemberSignature Language="F#" Value="member this.Kill : unit -&gt; unit" Usage="process.Kill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Interrompe imediatamente o processo associado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.Kill%2A> força o encerramento do processo, enquanto <xref:System.Diagnostics.Process.CloseMainWindow%2A> apenas solicita um encerramento. Quando um processo com uma interface gráfica está em execução, seu loop de mensagem está em um estado de espera. O loop de mensagem é executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. Chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A> envia uma solicitação para a próxima janela principal, que, em um aplicativo bem formado, fecha janelas filho e revoga todos executados loops de mensagem para o aplicativo. A solicitação para encerrar o processo chamando <xref:System.Diagnostics.Process.CloseMainWindow%2A> não força o aplicativo para sair. O aplicativo pode solicitar a verificação de usuário antes de encerrar ou ele poderá recusar sair. Para forçar o aplicativo para sair, use o <xref:System.Diagnostics.Process.Kill%2A> método. O comportamento de <xref:System.Diagnostics.Process.CloseMainWindow%2A> é idêntico de um usuário de fechar a janela principal do aplicativo, usando o menu do sistema. Portanto, a solicitação para encerrar o processo, fechando a janela principal não força o aplicativo para sair imediatamente.  
  
> [!NOTE]
>  O <xref:System.Diagnostics.Process.Kill%2A> método executa de forma assíncrona. Depois de chamar o <xref:System.Diagnostics.Process.Kill%2A> método, a chamada a <xref:System.Diagnostics.Process.WaitForExit%2A> método para aguardar o processo sair ou verifique o <xref:System.Diagnostics.Process.HasExited%2A> propriedade para determinar se o processo foi encerrado.  
  
 Editado pelo processo de dados ou recursos alocados para o processo podem ser perdidos se você chamar <xref:System.Diagnostics.Process.Kill%2A>. <xref:System.Diagnostics.Process.Kill%2A> faz com que um encerramento anormal do processo e deve ser usado somente quando necessário. <xref:System.Diagnostics.Process.CloseMainWindow%2A> Habilita um encerramento ordenado do processo e fecha todas as janelas, portanto, é preferível para aplicativos com uma interface. Se <xref:System.Diagnostics.Process.CloseMainWindow%2A> falhar, você pode usar <xref:System.Diagnostics.Process.Kill%2A> para finalizar o processo. <xref:System.Diagnostics.Process.Kill%2A> é a única maneira de encerrar os processos que não têm interfaces gráficas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.Kill%2A> e <xref:System.Diagnostics.Process.CloseMainWindow%2A> somente para processos em execução no computador local. Você não pode fazer com que processos em computadores remotos para sair. Você só pode exibir informações de processos em execução em computadores remotos.  
  
> [!NOTE]
>  Se a chamada para o <xref:System.Diagnostics.Process.Kill%2A> método é feito enquanto o processo está sendo encerrado no momento, um <xref:System.ComponentModel.Win32Exception> é lançada para acesso negado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível terminar o processo associado.  
  
- ou - 
O processo está sendo encerrado.  
  
- ou - 
O processo associado é um executável do Win16.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando chamar <see cref="M:System.Diagnostics.Process.Kill" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo já terminou.  
  
- ou - 
Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Environment.Exit(System.Int32)" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Start" />
      </Docs>
    </Member>
    <Member MemberName="LeaveDebugMode">
      <MemberSignature Language="C#" Value="public static void LeaveDebugMode ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void LeaveDebugMode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.LeaveDebugMode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub LeaveDebugMode ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void LeaveDebugMode();" />
      <MemberSignature Language="F#" Value="static member LeaveDebugMode : unit -&gt; unit" Usage="System.Diagnostics.Process.LeaveDebugMode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Tira um componente <see cref="T:System.Diagnostics.Process" /> do estado que permite a ele interagir com processos do sistema operacional que são executados em um modo especial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alguns processos de sistema operacional executado em um modo especial. A tentativa de ler propriedades de ou anexar a esses processos não for possível, a menos que você tenha chamado <xref:System.Diagnostics.Process.EnterDebugMode%2A> no componente. Chamar <xref:System.Diagnostics.Process.LeaveDebugMode%2A> quando você não precisa mais acesso a esses processos que são executados em modo especial.  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.EnterDebugMode" />
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Diagnostics.Process.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of the machine the running the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMachineName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do computador no qual o processo associado está em execução.</summary>
        <value>O nome do computador no qual o processo associado está em execução.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Você pode exibir dados de estatísticos e informações de processo para processos em execução em computadores remotos, mas você não podem chamar <xref:System.Diagnostics.Process.Start%2A>, <xref:System.Diagnostics.Process.CloseMainWindow%2A>, ou <xref:System.Diagnostics.Process.Kill%2A> em computadores remotos.  
  
> [!NOTE]
>  Quando o processo associado está em execução no computador local, essa propriedade retorna um ponto (".") para o nome do computador. Você deve usar o <xref:System.Environment.MachineName%2A?displayProperty=nameWithType> propriedade para obter o nome do computador correto.  
  
   
  
## Examples  
 Para usar o exemplo a seguir, você deve primeiro inicie pelo menos uma instância do bloco de notas em um computador remoto. O exemplo solicita o nome do computador remoto no qual o bloco de notas está em execução e, em seguida, exibe os respectivos <xref:System.Diagnostics.Process.ProcessName%2A>, <xref:System.Diagnostics.Process.Id%2A>, e <xref:System.Diagnostics.Process.MachineName%2A> propriedades para cada instância.  
  
 [!code-csharp[process_GetProcessesByName2_2#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_GetProcessesByName2_2/CS/process_getprocessesbyname2_2.cs#2)]
 [!code-vb[process_GetProcessesByName2_2#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_GetProcessesByName2_2/VB/process_getprocessesbyname2_2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcesses" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessById(System.Int32,System.String)" />
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="MainModule">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModule MainModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModule MainModule" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainModule" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainModule As ProcessModule" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModule ^ MainModule { System::Diagnostics::ProcessModule ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainModule : System.Diagnostics.ProcessModule" Usage="System.Diagnostics.Process.MainModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The main module of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainModule")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModule</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o módulo principal do processo associado.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessModule" /> usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. O <xref:System.Diagnostics.Process.MainModule%2A> propriedade permite que você exiba informações sobre o executável usado para iniciar o processo, incluindo o nome do módulo, nome de arquivo e os detalhes de memória do módulo.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainModule" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Um processo de 32 bits está tentando acessar os módulos de um processo de 64 bits.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
- ou - 
O processo foi encerrado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.Modules" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowHandle">
      <MemberSignature Language="C#" Value="public IntPtr MainWindowHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MainWindowHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MainWindowHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowHandle : nativeint" Usage="System.Diagnostics.Process.MainWindowHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The handle of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowHandle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de janela da janela principal do processo associado.</summary>
        <value>O identificador de janela gerado pelo sistema da janela principal do processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A janela principal é a janela aberta pelo processo que atualmente tem o foco (o <xref:System.Windows.Forms.Form.TopLevel%2A> formulário). Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto do qual obter o identificador da janela principal atual se ele tiver sido alterado. Em geral, como o identificador de janela é armazenado em cache, use <xref:System.Diagnostics.Process.Refresh%2A> antecipadamente para garantir que você irá recuperar o identificador atual.  
  
 Você pode obter o <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade somente para processos em execução no computador local. O <xref:System.Diagnostics.Process.MainWindowHandle%2A> propriedade é um valor que identifica exclusivamente a janela que está associada com o processo.  
  
 Um processo tem uma janela principal associada a ele somente se o processo tem uma interface gráfica. Se o processo associado não tiver uma janela principal, o <xref:System.Diagnostics.Process.MainWindowHandle%2A> valor é zero. O valor também é zero para processos que foram ocultos, ou seja, processa que não são visíveis na barra de tarefas. Isso pode ser o caso para processos que são exibidos como ícones na área de notificação, na extremidade direita da barra de tarefas.  
  
 Se você apenas iniciou um processo e quiser usar seu identificador de janela principal, considere usar o <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, uma exceção será gerada.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> não foi definido porque o processo foi encerrado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainWindowHandle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowTitle" />
        <altmember cref="P:System.Diagnostics.Process.MainModule" />
      </Docs>
    </Member>
    <Member MemberName="MainWindowTitle">
      <MemberSignature Language="C#" Value="public string MainWindowTitle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MainWindowTitle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MainWindowTitle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MainWindowTitle As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ MainWindowTitle { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MainWindowTitle : string" Usage="System.Diagnostics.Process.MainWindowTitle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The title of the main window of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMainWindowTitle")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a legenda da janela principal do processo.</summary>
        <value>O título da janela principal do processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um processo tem uma janela principal associada a ele somente se o processo tem uma interface gráfica. Se o processo associado não tiver uma janela principal (para que <xref:System.Diagnostics.Process.MainWindowHandle%2A> é zero), <xref:System.Diagnostics.Process.MainWindowTitle%2A> é uma cadeia de caracteres vazia (""). Se você apenas iniciou um processo e quiser usar seu título da janela principal, considere usar o <xref:System.Diagnostics.Process.WaitForInputIdle%2A> método para permitir que o processo seja iniciado, garantindo que o identificador de janela principal foi criado. Caso contrário, o sistema gerará uma exceção.  
  
> [!NOTE]
>  A janela principal é a janela que atualmente tem o foco; Observe que isso pode não ser a janela principal para o processo. Você deve usar o <xref:System.Diagnostics.Process.Refresh%2A> método para atualizar o <xref:System.Diagnostics.Process> objeto do qual obter o identificador da janela principal atual se ele tiver sido alterado.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas e recupera a legenda da janela principal do processo.  
  
 [!code-cpp[process_MainWindowTitle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_MainWindowTitle/CPP/process_mainwindowtitle.cpp#1)]
 [!code-csharp[process_MainWindowTitle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_MainWindowTitle/CS/process_mainwindowtitle.cs#1)]
 [!code-vb[process_MainWindowTitle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_MainWindowTitle/VB/process_mainwindowtitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">A propriedade <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> não foi definida, porque o processo foi encerrado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MainWindowTitle" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="MaxWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MaxWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MaxWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MaxWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MaxWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MaxWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MaxWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMaxWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho de conjunto de trabalho máximo permitido em bytes para o processo associado.</summary>
        <value>O tamanho máximo do conjunto de trabalho permitido na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções de seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e System. dll. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo que tem o tamanho do conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema de reserva uma quantidade de memória igual ao tamanho do conjunto para o processo de trabalho mínimo. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo estiver ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o tamanho do conjunto de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, a definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você pegar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínima ou máxima que é muito grande, pois assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho máximo do conjunto de trabalho é inválido. Ele deve ser maior ou igual ao tamanho mínimo de conjunto de trabalho.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de conjunto de trabalho não puderam ser recuperadas do recurso do processo associado.  
  
- ou - 
O identificador de processo é zero, porque o processo não foi iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MaxWorkingSet" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
- ou - 
O processo foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="MinWorkingSet">
      <MemberSignature Language="C#" Value="public IntPtr MinWorkingSet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int MinWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.MinWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWorkingSet As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr MinWorkingSet { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.MinWorkingSet : nativeint with get, set" Usage="System.Diagnostics.Process.MinWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The minimum amount of physical memory the process has required since it was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessMinWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o tamanho de conjunto de trabalho mínimo permitido em bytes para o processo associado.</summary>
        <value>O tamanho mínimo do conjunto de trabalho necessário na memória para o processo em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções de seu aplicativo é executado, incluindo as páginas em seus arquivos. dll e System. dll. Como o conjunto de trabalho cresce, aumenta a demanda por memória.  
  
 Um processo que tem o tamanho do conjunto de trabalho mínimo e máximo. Cada vez que um recurso de processo é criado, o sistema de reserva uma quantidade de memória igual ao tamanho do conjunto para o processo de trabalho mínimo. O Gerenciador de memória virtual tenta manter pelo menos a quantidade mínima de memória residente quando o processo estiver ativo, mas nunca mantém mais do que o tamanho máximo.  
  
 O sistema define o tamanho do conjunto de trabalho padrão. Você pode modificar esses tamanhos usando o <xref:System.Diagnostics.Process.MaxWorkingSet%2A> e <xref:System.Diagnostics.Process.MinWorkingSet%2A> membros. No entanto, a definir esses valores não garante que a memória será reservado ou residente.  
  
> [!NOTE]
>  Quando você aumenta o tamanho do conjunto de trabalho de um processo, você pegar a memória física do restante do sistema. Certifique-se de que você não solicitar um tamanho de conjunto de trabalho mínima ou máxima que é muito grande, pois assim pode prejudicar o desempenho do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">O tamanho mínimo do conjunto de trabalho é inválido. Ele deve ser menor ou igual ao tamanho máximo do conjunto de trabalho.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de conjunto de trabalho não puderam ser recuperadas do recurso do processo associado.  
  
- ou - 
O identificador de processo é zero, porque o processo não foi iniciado.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.MinWorkingSet" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.  
  
- ou - 
O processo foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessModuleCollection Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessModuleCollection Modules" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Modules" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modules As ProcessModuleCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessModuleCollection ^ Modules { System::Diagnostics::ProcessModuleCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : System.Diagnostics.ProcessModuleCollection" Usage="System.Diagnostics.Process.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The modules that are loaded as part of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessModules")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessModuleCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém os módulos que foram carregados pelo processo associado.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessModule" /> que representa os módulos que foram carregados pelo processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um módulo de processo representa o arquivo. dll ou .exe que é carregado em um processo específico. Um <xref:System.Diagnostics.ProcessModule> instância permite que você exiba informações sobre um módulo, incluindo o nome do módulo, nome de arquivo e os detalhes de memória do módulo.  
  
 Um processo pode carregar vários módulos na memória. Por exemplo, arquivos de .exe que carregar arquivos. dll adicional tem vários módulos.  
  
 Depois de iniciar o processo, essa coleção está vazia, até que o sistema tiver carregado o processo. Se o processo tem uma janela principal, você pode chamar <xref:System.Diagnostics.Process.WaitForInputIdle%2A> antes de recuperar essa propriedade para garantir que a coleção é não vazio quando você obter a lista.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Modules" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Modules" /> para o processo do sistema ou o tempo ocioso. Esses processos não têm módulos.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.Diagnostics.ProcessModule" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int NonpagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 NonpagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int NonpagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize : int" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use NonpagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.NonpagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória não paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, que o sistema alocou para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="NonpagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long NonpagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 NonpagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NonpagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long NonpagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.NonpagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are not pageable.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessNonpagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória não paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que não pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual da memória não paginada usada pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. As alocações de memória não paginável permanecem na memória do sistema e não são paginadas para o arquivo de paginação de memória virtual.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente à **Bytes de Pool não paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="OnExited">
      <MemberSignature Language="C#" Value="protected void OnExited ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnExited() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.OnExited" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnExited ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnExited();" />
      <MemberSignature Language="F#" Value="member this.OnExited : unit -&gt; unit" Usage="process.OnExited " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Aciona o evento <see cref="E:System.Diagnostics.Process.Exited" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.OnExited%2A> é o método de API que gera o <xref:System.Diagnostics.Process.Exited> eventos. Chamando <xref:System.Diagnostics.Process.OnExited%2A> faz com que o <xref:System.Diagnostics.Process.Exited> ocorrência do evento e é a única maneira de gerar o evento usando o <xref:System.Diagnostics.Process> componente. <xref:System.Diagnostics.Process.OnExited%2A> é usado principalmente ao derivar classes de componente.  
  
 Como uma alternativa ao <xref:System.Diagnostics.Process.OnExited%2A>, você pode escrever seu próprio manipulador de eventos. Você cria seu próprio delegado de manipulador de eventos e seu próprio método de manipulação de eventos.  
  
> [!NOTE]
>  Se você estiver usando o ambiente do Visual Studio, um delegado de manipulador de eventos (AddOnExited) e um método de manipulação de eventos (Process1_Exited) são criados para você quando você arrasta um <xref:System.Diagnostics.Process> componente em um formulário e clique duas vezes no ícone. O código que você cria para ser executado quando o <xref:System.Diagnostics.Process.Exited> evento ocorre são inseridas no procedimento Process1_Exited. Não é preciso criar o <xref:System.Diagnostics.Process.OnExited%2A> membro, porque ele é implementado para você.  
  
 A geração de um evento invoca o manipulador de eventos por meio de um delegado. Para obter uma visão geral, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 O exemplo a seguir mostra como usar o <xref:System.Diagnostics.Process.OnExited%2A> método em uma classe derivada.  
  
 [!code-csharp[OnExitSample#1](~/samples/snippets/csharp/VS_Snippets_CLR/onexitsample/cs/program.cs#1)]
 [!code-vb[OnExitSample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/onexitsample/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="OutputDataReceived">
      <MemberSignature Language="C#" Value="public event System.Diagnostics.DataReceivedEventHandler OutputDataReceived;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Diagnostics.DataReceivedEventHandler OutputDataReceived" />
      <MemberSignature Language="DocId" Value="E:System.Diagnostics.Process.OutputDataReceived" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event OutputDataReceived As DataReceivedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Diagnostics::DataReceivedEventHandler ^ OutputDataReceived;" />
      <MemberSignature Language="F#" Value="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " Usage="member this.OutputDataReceived : System.Diagnostics.DataReceivedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Indicates if the process component is associated with a real process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessAssociated")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.DataReceivedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ocorre sempre que um aplicativo grava uma linha no fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> redirecionado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.OutputDataReceived> evento indica que associado <xref:System.Diagnostics.Process> escreveu uma linha, terminando com um caractere de nova linha, para redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  
  
 O evento é habilitado durante operações de leitura assíncronas em <xref:System.Diagnostics.Process.StandardOutput%2A>. Para iniciar operações de leitura assíncronas, você deve redirecionar o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo de um <xref:System.Diagnostics.Process>, adicione o manipulador de eventos a <xref:System.Diagnostics.Process.OutputDataReceived> eventos e chamadas <xref:System.Diagnostics.Process.BeginOutputReadLine%2A>. Depois disso, o <xref:System.Diagnostics.Process.OutputDataReceived> sinais de eventos sempre que o processo grava uma linha para redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir, até que o processo é encerrado ou chame <xref:System.Diagnostics.Process.CancelOutputRead%2A>.  
  
> [!NOTE]
>  O aplicativo que está processando a saída assíncrona deve chamar o <xref:System.Diagnostics.Process.WaitForExit%2A> método para garantir que o buffer de saída foi liberado.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como executar operações de leitura assíncronas em redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo do `ipconfig` comando.  
  
 O exemplo cria um delegado de evento para o `OutputHandler` manipulador de eventos e a associa com o <xref:System.Diagnostics.Process.OutputDataReceived> eventos. O manipulador de eventos recebe linhas de texto de redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, formata o texto e o salva em uma cadeia de caracteres de saída que é mostrada posteriormente na janela do console de exemplo.  
  
 [!code-cpp[Process_AsyncStreams#4](~/samples/snippets/cpp/VS_Snippets_CLR/process_asyncstreams/CPP/datareceivedevent.cpp#4)]
 [!code-csharp[Process_AsyncStreams#4](~/samples/snippets/csharp/VS_Snippets_CLR/process_asyncstreams/CS/datareceivedevent.cs#4)]
 [!code-vb[Process_AsyncStreams#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_asyncstreams/VB/datareceivedevent.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="M:System.Diagnostics.Process.BeginOutputReadLine" />
        <altmember cref="M:System.Diagnostics.Process.CancelOutputRead" />
        <altmember cref="T:System.Diagnostics.DataReceivedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize">
      <MemberSignature Language="C#" Value="public int PagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize : int" Usage="System.Diagnostics.Process.PagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada pelo processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of bytes that are paged.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginada, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual da memória no arquivo de paginação de memória virtual usada pelo processo, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual no disco. Para obter o tamanho da memória usada pelo sistema operacional para o processo, use o <xref:System.Diagnostics.Process.PagedSystemMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente à **Bytes de arquivo de página** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas e, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize">
      <MemberSignature Language="C#" Value="public int PagedSystemMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PagedSystemMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PagedSystemMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize : int" Usage="System.Diagnostics.Process.PagedSystemMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PagedSystemMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PagedSystemMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginável do sistema, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória, em bytes, o sistema alocou para o processo associado que pode ser gravado para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PagedSystemMemorySize64">
      <MemberSignature Language="C#" Value="public long PagedSystemMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PagedSystemMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PagedSystemMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PagedSystemMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PagedSystemMemorySize64 : int64" Usage="System.Diagnostics.Process.PagedSystemMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of paged system memory in bytes.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPagedSystemMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória paginável do sistema, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória do sistema, em bytes, alocada para o processo associado que pode ser gravada no arquivo de paginação de memória virtual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho atual de memória paginável do sistema usado pelo processo, em bytes. Memória do sistema é a memória física usada pelo sistema operacional e é dividida em pools e não pagináveis. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual no disco. Para obter o tamanho da memória de aplicativo usado pelo processo, use o <xref:System.Diagnostics.Process.PagedMemorySize64%2A> propriedade.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes de Pool paginável** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedSystemMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.NonpagedSystemMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize">
      <MemberSignature Language="C#" Value="public int PeakPagedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakPagedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakPagedMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize : int" Usage="System.Diagnostics.Process.PeakPagedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakPagedMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakPagedMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória, em bytes, no arquivo de paginação de memória virtual usado pelo processo associado.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada pelo processo associado que poderia ser escrito para o arquivo de paginação de memória virtual.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakPagedMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakPagedMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakPagedMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakPagedMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakPagedMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakPagedMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakPagedMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of paged memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakPagedMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória, em bytes, no arquivo de paginação de memória virtual usado pelo processo associado.</summary>
        <value>A quantidade máxima de memória, em bytes, alocada no arquivo de paginação de memória virtual para o processo associado desde que ele foi iniciado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado pelo valor dessa propriedade representa o tamanho máximo de memória no arquivo de paginação de memória virtual usada pelo processo desde que ele foi iniciado, em bytes. O sistema operacional usa o arquivo de paginação de memória virtual em conjunto com memória física para gerenciar o espaço de endereço virtual para cada processo. Quando a memória paginável não está em uso, eles podem ser transferidos para o arquivo de paginação de memória virtual no disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de Bytes do arquivo de paginação** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PagedMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize">
      <MemberSignature Language="C#" Value="public int PeakVirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakVirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakVirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize : int" Usage="System.Diagnostics.Process.PeakVirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakVirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakVirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, que o processo associado solicitou.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakVirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long PeakVirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakVirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakVirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakVirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakVirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.PeakVirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of virtual memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória virtual, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória virtual, em bytes, alocada ao processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho máximo de memória virtual usada pelo processo desde que ele foi iniciado, em bytes. O sistema operacional é mapeado para o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou para páginas armazenadas no arquivo de paginação de memória virtual no disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente à **pico de Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet">
      <MemberSignature Language="C#" Value="public int PeakWorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PeakWorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PeakWorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet : int" Usage="System.Diagnostics.Process.PeakWorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PeakWorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PeakWorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho do conjunto de trabalho máximo para o processo associado, em bytes.</summary>
        <value>A quantidade máxima de memória física que o processo associado solicitou uma só vez, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo módulos de processo e as bibliotecas do sistema.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="PeakWorkingSet64">
      <MemberSignature Language="C#" Value="public long PeakWorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PeakWorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PeakWorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PeakWorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PeakWorkingSet64 : int64" Usage="System.Diagnostics.Process.PeakWorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The maximum amount of system memory used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPeakWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade máxima de memória física, em bytes, usada pelo processo associado.</summary>
        <value>A quantidade máxima de memória física, em bytes, alocada para o processo associado desde sua inicialização.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho máximo de memória usada pelo processo desde que ele foi iniciado, em bytes do conjunto de trabalhar. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções de como os módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **pico de conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
      </Docs>
    </Member>
    <Member MemberName="PriorityBoostEnabled">
      <MemberSignature Language="C#" Value="public bool PriorityBoostEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool PriorityBoostEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityBoostEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool PriorityBoostEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityBoostEnabled : bool with get, set" Usage="System.Diagnostics.Process.PriorityBoostEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Process will be of higher priority while it is actively used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityBoostEnabled")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define um valor que indica se a prioridade do processo associada deve temporariamente ser aumentada pelo sistema operacional quando o foco estiver na janela principal.</summary>
        <value><see langword="true" /> se o aumento dinâmico da prioridade de processo deve ocorrer para um processo quando ele sair do estado de espera; caso contrário, <see langword="false" />. O padrão é <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um thread é executado em um processo para o qual a classe de prioridade tem um dos valores de enumeração de prioridade dinâmica (<xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>), o sistema aumenta temporariamente a prioridade do thread quando ele é retirado de um estado de espera. Essa ação impede que outros processos a interromper o processamento do thread atual. O <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> configuração afeta todos os threads existentes e os threads criados posteriormente pelo processo. Para restaurar o comportamento normal, defina as <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> propriedade para `false`.  
  
> [!NOTE]
>  Aumentando demais a prioridade pode esgotar os recursos das funções de rede, causando problemas com outras tarefas de sistema operacional e essenciais do sistema operacional.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível recuperar as informações de aumento de prioridade do recurso de processo associado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.  
  
- ou - 
O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PriorityBoostEnabled" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PriorityClass" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="PriorityClass">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessPriorityClass PriorityClass { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Diagnostics.ProcessPriorityClass PriorityClass" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PriorityClass" />
      <MemberSignature Language="VB.NET" Value="Public Property PriorityClass As ProcessPriorityClass" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessPriorityClass PriorityClass { System::Diagnostics::ProcessPriorityClass get(); void set(System::Diagnostics::ProcessPriorityClass value); };" />
      <MemberSignature Language="F#" Value="member this.PriorityClass : System.Diagnostics.ProcessPriorityClass with get, set" Usage="System.Diagnostics.Process.PriorityClass" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The priority that the threads in the process run relative to.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPriorityClass")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessPriorityClass</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define a categoria geral de prioridade para o processo associado.</summary>
        <value>A categoria de prioridade do processo associado, do qual o <see cref="P:System.Diagnostics.Process.BasePriority" /> do processo é calculado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Uma classe de prioridade de processo abrange uma gama de níveis de prioridade de thread. Threads com prioridades diferentes que estão em execução no processo executado em relação a classe de prioridade do processo. Win32 usa quatro classes de prioridade com sete níveis de prioridade-base por classe. Essas classes de prioridade de processo são capturados na <xref:System.Diagnostics.ProcessPriorityClass> enumeração, que permite que você defina a prioridade do processo como <xref:System.Diagnostics.ProcessPriorityClass.Idle>, <xref:System.Diagnostics.ProcessPriorityClass.Normal>, <xref:System.Diagnostics.ProcessPriorityClass.High>, <xref:System.Diagnostics.ProcessPriorityClass.AboveNormal>, <xref:System.Diagnostics.ProcessPriorityClass.BelowNormal>, ou <xref:System.Diagnostics.ProcessPriorityClass.RealTime>. Com base no tempo decorrida ou outras, aumenta o nível de prioridade básica pode ser alterada pelo sistema operacional quando um processo precisa ser colocado à frente dos outros para acesso ao processador. Além disso, você pode definir o <xref:System.Diagnostics.Process.PriorityBoostEnabled%2A> para temporariamente aumentar o nível de prioridade de threads que foram executadas fora do estado de espera. A prioridade é redefinida quando o processo de retorna ao estado de espera.  
  
 O <xref:System.Diagnostics.Process.BasePriority%2A> propriedade permite que você exiba a prioridade inicial que é atribuída a um processo. No entanto, porque ele é somente leitura, você não pode usar o <xref:System.Diagnostics.Process.BasePriority%2A> propriedade para definir a prioridade de um processo. Para alterar a prioridade, use o <xref:System.Diagnostics.Process.PriorityClass%2A> propriedade, que obtém ou define a categoria geral de prioridade para o processo.  
  
 A classe de prioridade não pode ser exibida usando o Monitor do sistema. A tabela a seguir mostra a relação entre o <xref:System.Diagnostics.Process.BasePriority%2A> e <xref:System.Diagnostics.Process.PriorityClass%2A> valores.  
  
|BasePriority|Classe de prioridade|  
|------------------|-------------------|  
|4|<xref:System.Diagnostics.ProcessPriorityClass.Idle>|  
|8|<xref:System.Diagnostics.ProcessPriorityClass.Normal>|  
|13|<xref:System.Diagnostics.ProcessPriorityClass.High>|  
|24|<xref:System.Diagnostics.ProcessPriorityClass.RealTime>|  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de prioridade do processo não puderam ser definidas nem recuperadas do recurso do processo associado.  
  
- ou - 
O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PriorityClass" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não está disponível.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Você definiu o <see cref="P:System.Diagnostics.Process.PriorityClass" /> como <see langword="AboveNormal" /> ou <see langword="BelowNormal" /> ao usar o Windows 98 ou Windows Millennium Edition (Windows Me). Essas plataformas não dão suporte a esses valores para a classe de prioridade.</exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">A classe de prioridade não pode ser definida porque ela não usa um valor válido, conforme definido na enumeração <see cref="T:System.Diagnostics.ProcessPriorityClass" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
        <altmember cref="P:System.Diagnostics.Process.PriorityBoostEnabled" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize">
      <MemberSignature Language="C#" Value="public int PrivateMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 PrivateMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int PrivateMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize : int" Usage="System.Diagnostics.Process.PrivateMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use PrivateMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.PrivateMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória privada, em bytes, alocada ao processo associado.</summary>
        <value>O número de bytes alocados pelo processo associado que não podem ser compartilhados com outros processos.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PrivateMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="PrivateMemorySize64">
      <MemberSignature Language="C#" Value="public long PrivateMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PrivateMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivateMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PrivateMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivateMemorySize64 : int64" Usage="System.Diagnostics.Process.PrivateMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of memory exclusively used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivateMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória privada, em bytes, alocada ao processo associado.</summary>
        <value>A quantidade de memória, em bytes, alocada ao processo associado que não pode ser compartilhada com outros processos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual da memória usada pelo processo, em bytes, que não pode ser compartilhada com outros processos.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente à **Bytes particulares** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="PrivilegedProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan PrivilegedProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PrivilegedProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PrivilegedProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PrivilegedProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PrivilegedProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.PrivilegedProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent inside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessPrivilegedProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador privilegiado para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo gastou executando o código no núcleo do sistema operacional.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="ProcessName">
      <MemberSignature Language="C#" Value="public string ProcessName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ProcessName" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProcessName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ProcessName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessName : string" Usage="System.Diagnostics.Process.ProcessName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The name of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessName")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o nome do processo.</summary>
        <value>O nome que o sistema usa para identificar o processo para o usuário.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.ProcessName%2A> propriedade contém um nome de arquivo executável, como Outlook, que não inclui a extensão .exe ou o caminho. É útil para obter e manipular todos os processos que estão associados com o mesmo arquivo executável.  
  
> [!NOTE]
>  Na [!INCLUDE[Win2kFamily](~/includes/win2kfamily-md.md)] sistemas operacionais, o <xref:System.Diagnostics.Process.ProcessName%2A> propriedade poderá ser truncada a 15 caracteres, se as informações do módulo de processo não podem ser obtidas.  
  
 Você pode chamar <xref:System.Diagnostics.Process.GetProcessesByName%2A>, passando para ele um nome de arquivo executável, para recuperar uma matriz que contém todas as instâncias em execução no computador especificado. Você pode usar essa matriz, por exemplo, para desligar todas as instâncias em execução do arquivo executável.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem um identificador ou nenhum processo está associado ao <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
O processo associado foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.NotSupportedException">O processo não está neste computador.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.GetProcessesByName(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessorAffinity">
      <MemberSignature Language="C#" Value="public IntPtr ProcessorAffinity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int ProcessorAffinity" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.ProcessorAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Property ProcessorAffinity As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr ProcessorAffinity { IntPtr get(); void set(IntPtr value); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorAffinity : nativeint with get, set" Usage="System.Diagnostics.Process.ProcessorAffinity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Allowed processor that can be used by this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessProcessorAffinity")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define os processadores nos quais os threads desse processo podem ser agendados para execução.</summary>
        <value>Um bitmask que representa os processadores nos quais os threads do processo associado podem ser executados. O padrão depende do número de processadores no computador. O valor padrão é 2 <sup>n</sup> -1, em que n é o número de processadores.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 No Windows 2000 e posterior, um thread em um processo pode migrar do processador, com cada migração recarregar o cache do processador. Sob cargas de sistema pesadas, especificar qual processador deve executar um thread específico pode melhorar o desempenho, reduzindo o número de vezes que o cache do processador é recarregado. A associação entre um processador e um thread é chamada a afinidade do processador.  
  
 Cada processador é representado como um pouco. Bit 0 é o processador de um, o bit 1 é o processador de dois e assim por diante. Se você definir um pouco com o valor 1, o processador correspondente é selecionado para a atribuição de thread. Quando você define o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor como zero, o sistema operacional do agendamento de conjunto de algoritmos a afinidade do thread. Quando o <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valor é definido como qualquer valor diferente de zero, o valor será interpretado como um bitmask que especifica esses processadores qualificados para seleção.  
  
 A tabela a seguir mostra uma seleção de <xref:System.Diagnostics.Process.ProcessorAffinity%2A> valores para um sistema com oito processadores.  
  
|Máscara de bits|Valor binário|Processadores qualificados|  
|-------------|------------------|-------------------------|  
|0x0001|00000000 00000001|1|  
|0x0003|00000000 00000011|1 e 2|  
|0x0007|00000000 00000111|1, 2 e 3|  
|0x0009|00000000 00001001|1 e 4|  
|0x007F|00000000 01111111|1, 2, 3, 4, 5, 6 e 7|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">As informações de <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> não puderam ser definidas nem recuperadas do recurso do processo associado.  
  
- ou - 
O identificador de processo é zero. (O processo não foi iniciado.)</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo <see cref="P:System.Diagnostics.Process.Id" /> não estava disponível.  
  
- ou - 
O processo foi encerrado.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Refresh();" />
      <MemberSignature Language="F#" Value="member this.Refresh : unit -&gt; unit" Usage="process.Refresh " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Descarta informações sobre o processo associado que foi armazenado em cache dentro do componente do processo.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Depois de <xref:System.Diagnostics.Process.Refresh%2A> é chamado, a primeira solicitação para obter informações sobre cada propriedade faz com que o componente do processo obter um novo valor do processo associado.  
  
 Quando um <xref:System.Diagnostics.Process> componente está associado um recurso de processo, os valores de propriedade a <xref:System.Diagnostics.Process> imediatamente são preenchidos acordo com o status do processo associado. Se as informações sobre o processo associado for alterado posteriormente, essas alterações não são refletidas no <xref:System.Diagnostics.Process> do componente armazenado em cache os valores. O <xref:System.Diagnostics.Process> componente é um instantâneo de recurso do processo no momento em que elas estão associadas. Para exibir os valores atuais para o processo associado, chame o <xref:System.Diagnostics.Process.Refresh%2A> método.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. Ele então recupera o uso de memória física do processo associado intervalos de 2 segundos por um máximo de 10 segundos. O exemplo detecta se o processo será encerrado antes de 10 segundos. O exemplo fecha o processo se ele ainda está em execução após 10 segundos.  
  
 [!code-cpp[process_refresh#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_refresh/CPP/process_refresh.cpp#1)]
 [!code-csharp[process_refresh#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_refresh/CS/process_refresh.cs#1)]
 [!code-vb[process_refresh#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_refresh/VB/process_refresh.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Responding">
      <MemberSignature Language="C#" Value="public bool Responding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Responding" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Responding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Responding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Responding { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Responding : bool" Usage="System.Diagnostics.Process.Responding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Is this process responsive.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessResponding")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um valor que indica se a interface do usuário do processo está respondendo.</summary>
        <value><see langword="true" /> se a interface do usuário do processo associado estiver respondendo ao sistema; caso contrário, <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Se um processo tem uma interface de usuário, o <xref:System.Diagnostics.Process.Responding%2A> propriedade entra em contato com a interface do usuário para determinar se o processo está respondendo à entrada do usuário. Se a interface não responder imediatamente, o <xref:System.Diagnostics.Process.Responding%2A> propriedade retorna `false`. Use essa propriedade para determinar se a interface do processo associado tiver parado de responder.  
  
 Se o processo não tem um <xref:System.Diagnostics.Process.MainWindowHandle%2A>, essa propriedade retornará `true`.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <exception cref="T:System.InvalidOperationException">Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.Responding" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MainWindowHandle" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class Microsoft.Win32.SafeHandles.SafeProcessHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeProcessHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Microsoft::Win32::SafeHandles::SafeProcessHandle ^ SafeHandle { Microsoft::Win32::SafeHandles::SafeProcessHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : Microsoft.Win32.SafeHandles.SafeProcessHandle" Usage="System.Diagnostics.Process.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>Microsoft.Win32.SafeHandles.SafeProcessHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador nativo para esse processo.</summary>
        <value>O identificador nativo para esse processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O identificador só estará disponível se o componente de discagem iniciou o processo.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SessionId">
      <MemberSignature Language="C#" Value="public int SessionId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SessionId" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SessionId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SessionId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SessionId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SessionId : int" Usage="System.Diagnostics.Process.SessionId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The session ID for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoNotSupported("")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSessionId")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o identificador de sessão dos Serviços de Terminal para o processo associado.</summary>
        <value>O identificador de sessão dos Serviços de Terminal para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O <xref:System.Diagnostics.Process.SessionId%2A> propriedade identifica a sessão na qual o aplicativo está sendo executado.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Não há nenhuma sessão associada a este processo.</exception>
        <exception cref="T:System.InvalidOperationException">Não há nenhum processo associado a esse identificador de sessão.  
  
- ou - 
O processo associado não está neste computador.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A propriedade <see cref="P:System.Diagnostics.Process.SessionId" /> não é compatível com o Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StandardError">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardError" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardError As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardError { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardError : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard error stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardError")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para ler a saída de erro do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de erro padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> grava o texto para seu fluxo de erro padrão, que o texto normalmente é exibido no console. Redirecionando a <xref:System.Diagnostics.Process.StandardError%2A> fluxo, você pode manipular ou suprimir a saída de erro de um processo. Por exemplo, o texto de filtro, formatá-lo de forma diferente ou gravar a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardError%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardError%2A?displayProperty=nameWithType> para `true`. Caso contrário, lendo o <xref:System.Diagnostics.Process.StandardError%2A> stream gera uma exceção.  
  
 Redirecionado <xref:System.Diagnostics.Process.StandardError%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída de erro do processo. Eles síncrona ler operações não forem concluídas até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardError%2A> transmitir ou fecha o fluxo.  
  
 Em contraste, <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> operações de leitura assíncrona de início no <xref:System.Diagnostics.Process.StandardError%2A> stream. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações introduzem uma dependência entre o chamador lendo o <xref:System.Diagnostics.Process.StandardError%2A> fluxo e o filho de processo de gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê do fluxo redirecionado de um processo filho, ele é dependente no filho. O chamador aguarda a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente no pai. O processo filho aguarda a próxima operação de gravação até que o pai lê do fluxo completo ou fecha o fluxo. Os resultados da condição de deadlock quando o chamador e o processo filho aguardar uns aos outros para concluir uma operação, e não pode prosseguir. Você pode evitar deadlocks, avaliando as dependências entre o chamador e o processo filho.  

Os dois últimos exemplos desta seção usam a <xref:System.Diagnostics.Process.Start%2A> método para iniciar um arquivo executável chamado *Write500Lines.exe*. O exemplo a seguir contém seu código-fonte.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

O exemplo a seguir mostra como ler de um fluxo de erro redirecionados e aguarde até que o processo filho sair. Evita uma condição de deadlock, chamando `p.StandardError.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode resultar se o pai do processo de chamadas `p.WaitForExit` antes de `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve aguardar indefinidamente para o processo filho sair. O processo filho seria aguardar indefinidamente para o pai ler do completo <xref:System.Diagnostics.Process.StandardError%2A> stream.   

[!code-csharp[Reading from the error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standarderror/stderror-sync.cs)]
[!code-vb[Reading from the error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standarderror/stderror-sync.vb)]  

Há um problema semelhante quando você ler todo o texto de saída padrão e fluxos de erro padrão. O exemplo a seguir executa uma operação de leitura em ambos os fluxos. Ele evita a condição de deadlock pela execução assíncrona de operações de leitura a <xref:System.Diagnostics.Process.StandardError%2A> stream. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido por `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve aguardar indefinidamente para o processo filho fechar sua <xref:System.Diagnostics.Process.StandardOutput%2A> stream. O processo filho seria aguardar indefinidamente para o pai ler do completo <xref:System.Diagnostics.Process.StandardError%2A> stream.  
[!code-csharp[Reading from both streams](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]
[!code-vb[Reading from both streams](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]  

Você pode usar operações de leitura assíncronas para evitar essas dependências e seu potenciais de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Você não pode misturar operações síncronas e assíncronas de leitura em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Por exemplo, não seguem <xref:System.Diagnostics.Process.BeginErrorReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> sobre o <xref:System.Diagnostics.Process.StandardError%2A> stream, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes em modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 O exemplo a seguir usa o `net use` comando junto com um usuário fornecido pelo argumento para mapear um recurso de rede. Em seguida, ele lê o fluxo de erro padrão do comando net e grava no console.  
  
 [!code-cpp[Process_StandardError#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardError/CPP/source.cpp#1)]
 [!code-csharp[Process_StandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardError/CS/source.cs#1)]
 [!code-vb[Process_StandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardError/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> não foi definido para o redirecionamento; verifique se <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> foi definido como <see langword="true" /> e se <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> foi definido como <see langword="false" />.  
  
- ou - 
O fluxo <see cref="P:System.Diagnostics.Process.StandardError" /> foi aberto para operações de leitura assíncronas com <see cref="M:System.Diagnostics.Process.BeginErrorReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" />
      </Docs>
    </Member>
    <Member MemberName="StandardInput">
      <MemberSignature Language="C#" Value="public System.IO.StreamWriter StandardInput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamWriter StandardInput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardInput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardInput As StreamWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamWriter ^ StandardInput { System::IO::StreamWriter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardInput : System.IO.StreamWriter" Usage="System.Diagnostics.Process.StandardInput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard input stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardInput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para gravar a entrada do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamWriter" /> que pode ser usado para gravar o fluxo de entrada padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Diagnostics.Process> pode ler o texto de entrada do fluxo de entrada padrão, normalmente o teclado. Redirecionando a <xref:System.Diagnostics.Process.StandardInput%2A> fluxo, você pode especificar programaticamente a entrada. Por exemplo, em vez de usar a entrada do teclado, você pode fornecer o texto do conteúdo de um arquivo designado ou saída de outro aplicativo.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardInput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardInput%2A?displayProperty=nameWithType> para `true`. Caso contrário, gravando o <xref:System.Diagnostics.Process.StandardInput%2A> stream gera uma exceção.  
  
   
  
## Examples  
 O exemplo a seguir ilustra como redirecionar o <xref:System.Diagnostics.Process.StandardInput%2A> fluxo de um processo. O exemplo inicia o `sort` com entrada redirecionada. Ele, em seguida, solicita ao usuário para o texto e a passará para o `sort` processo por meio de redirecionado <xref:System.Diagnostics.Process.StandardInput%2A> stream. O `sort` os resultados são exibidos ao usuário no console.  
  
 [!code-cpp[Process_StandardInput#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardInput/CPP/process_standardinput.cpp#1)]
 [!code-csharp[Process_StandardInput#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardInput/CS/process_standardinput.cs#1)]
 [!code-vb[Process_StandardInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardInput/VB/process_standardinput.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardInput" /> não foi definido porque <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" /> está definido como <see langword="false" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardOutput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="StandardOutput">
      <MemberSignature Language="C#" Value="public System.IO.StreamReader StandardOutput { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.StreamReader StandardOutput" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StandardOutput As StreamReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::StreamReader ^ StandardOutput { System::IO::StreamReader ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StandardOutput : System.IO.StreamReader" Usage="System.Diagnostics.Process.StandardOutput" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Standard output stream of the process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStandardOutput")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IO.StreamReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém um fluxo usado para ler a saída textual do aplicativo.</summary>
        <value>Um <see cref="T:System.IO.StreamReader" /> que pode ser usado para ler o fluxo de saída padrão do aplicativo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando um <xref:System.Diagnostics.Process> grava o texto para seu fluxo padrão, que o texto normalmente é exibido no console. Redirecionando a <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo, você pode manipular ou suprimir a saída de um processo. Por exemplo, o texto de filtro, formatá-lo de forma diferente ou gravar a saída para o console e um arquivo de log designado.  
  
> [!NOTE]
>  Para usar <xref:System.Diagnostics.Process.StandardOutput%2A>, você deve definir <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A?displayProperty=nameWithType> à `false`, e você deve definir <xref:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput%2A?displayProperty=nameWithType> para `true`. Caso contrário, lendo o <xref:System.Diagnostics.Process.StandardOutput%2A> stream gera uma exceção.  
  
 Redirecionado <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo pode ser lido de forma síncrona ou assíncrona. Métodos como <xref:System.IO.StreamReader.Read%2A>, <xref:System.IO.StreamReader.ReadLine%2A>, e <xref:System.IO.StreamReader.ReadToEnd%2A> executar operações de leitura síncronas no fluxo de saída do processo. Eles síncrona ler operações não forem concluídas até associado <xref:System.Diagnostics.Process> grava seu <xref:System.Diagnostics.Process.StandardOutput%2A> transmitir ou fecha o fluxo.  
  
 Em contraste, <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> operações de leitura assíncrona de início no <xref:System.Diagnostics.Process.StandardOutput%2A> stream. Esse método permite que um manipulador de eventos designado para a saída de fluxo e retorna imediatamente para o chamador, que pode executar outras tarefas enquanto a saída de fluxo é direcionada para o manipulador de eventos.  
  
 Síncrona ler operações introduzem uma dependência entre o chamador lendo o <xref:System.Diagnostics.Process.StandardOutput%2A> fluxo e o filho de processo de gravação nesse fluxo. Essas dependências podem resultar em condições de deadlock. Quando o chamador lê do fluxo redirecionado de um processo filho, ele é dependente no filho. O chamador aguarda a operação de leitura até que o filho grava no fluxo ou fecha o fluxo. Quando o processo filho grava dados suficientes para preencher seu fluxo redirecionado, ele é dependente no pai. O processo filho aguarda a próxima operação de gravação até que o pai lê do fluxo completo ou fecha o fluxo. Os resultados da condição de deadlock quando o chamador e o processo filho aguardar uns aos outros para concluir uma operação, e não pode prosseguir. Você pode evitar deadlocks, avaliando as dependências entre o chamador e o processo filho.  

Os dois últimos exemplos desta seção usam a <xref:System.Diagnostics.Process.Start%2A> método para iniciar um arquivo executável chamado *Write500Lines.exe*. O exemplo a seguir contém seu código-fonte.

[!code-csharp[Executable launched by Process.Start](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/write500lines.cs)]
[!code-vb[Executable launched by Process.Start](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/write500lines.vb)]

O exemplo a seguir mostra como ler de um fluxo redirecionado e aguarde até que o processo filho sair. O exemplo evita uma condição de deadlock, chamando `p.StandardOutput.ReadToEnd` antes de `p.WaitForExit`. Uma condição de deadlock pode resultar se o pai do processo de chamadas `p.WaitForExit` antes de `p.StandardOutput.ReadToEnd` e o processo filho grava texto suficiente para preencher o fluxo redirecionado. O processo pai deve aguardar indefinidamente para o processo filho sair. O processo filho seria aguardar indefinidamente para o pai ler do completo <xref:System.Diagnostics.Process.StandardOutput%2A> stream.  

[!code-csharp[Reading synchronously from a redirected output stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-sync.cs)]  
[!code-vb[Reading synchronously from a redirected output stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-sync.vb)]  

Há um problema semelhante quando você ler todo o texto de saída padrão e fluxos de erro padrão. O exemplo a seguir executa uma operação de leitura em ambos os fluxos. Ele evita a condição de deadlock pela execução assíncrona de operações de leitura a <xref:System.Diagnostics.Process.StandardError%2A> stream. Resultados de uma condição de deadlock se o pai processar chamadas `p.StandardOutput.ReadToEnd` seguido por `p.StandardError.ReadToEnd` e o processo filho grava texto suficiente para preencher seu fluxo de erro. O processo pai deve aguardar indefinidamente para o processo filho fechar sua <xref:System.Diagnostics.Process.StandardOutput%2A> stream. O processo filho seria aguardar indefinidamente para o pai ler do completo <xref:System.Diagnostics.Process.StandardError%2A> stream.   
[!code-csharp[Reading from a redirected output and error stream](~/samples/snippets/csharp/api/system.diagnostics/process/standardoutput/stdoutput-async.cs)]  
[!code-vb[Reading from a redirected output and error stream](~/samples/snippets/visualbasic/api/system.diagnostics/process/standardoutput/stdoutput-async.vb)]    
  
 Você pode usar operações de leitura assíncronas para evitar essas dependências e seu potenciais de deadlock. Como alternativa, você pode evitar a condição de deadlock criando dois threads e lendo a saída de cada fluxo em um thread separado.  
  
> [!NOTE]
>  Você não pode misturar operações síncronas e assíncronas de leitura em um fluxo redirecionado. Uma vez o fluxo redirecionado de um <xref:System.Diagnostics.Process> é aberto no modo assíncrono ou síncrono, todas as adicionais de leitura operações naquele fluxo devem estar no mesmo modo. Por exemplo, não seguem <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> com uma chamada para <xref:System.IO.StreamReader.ReadLine%2A> sobre o <xref:System.Diagnostics.Process.StandardOutput%2A> stream, ou vice-versa. No entanto, você pode ler os dois fluxos diferentes em modos diferentes. Por exemplo, você pode chamar <xref:System.Diagnostics.Process.BeginOutputReadLine%2A> e, em seguida, chame <xref:System.IO.StreamReader.ReadLine%2A> para o <xref:System.Diagnostics.Process.StandardError%2A> stream.  
  
   
  
## Examples  
 O exemplo a seguir executa o comando ipconfig.exe e redireciona a saída padrão para janela do console de exemplo.  
  
 [!code-cpp[Process_StandardOutput#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_StandardOutput/CPP/process_standardoutput.cpp#2)]
 [!code-csharp[Process_StandardOutput#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_StandardOutput/CS/process_standardoutput.cs#2)]
 [!code-vb[Process_StandardOutput#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_StandardOutput/VB/process_standardoutput.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> não foi definido para o redirecionamento; verifique se <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> foi definido como <see langword="true" /> e se <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> foi definido como <see langword="false" />.  
  
- ou - 
O fluxo <see cref="P:System.Diagnostics.Process.StandardOutput" /> foi aberto para operações de leitura assíncronas com <see cref="M:System.Diagnostics.Process.BeginOutputReadLine" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StandardInput" />
        <altmember cref="P:System.Diagnostics.Process.StandardError" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicia um recurso de processo e o associa a um componente <see cref="T:System.Diagnostics.Process" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public bool Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start" />
      <MemberSignature Language="VB.NET" Value="Public Function Start () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; bool" Usage="process.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicia (ou reutiliza) o recurso do processo que é especificado pela propriedade <see cref="P:System.Diagnostics.Process.StartInfo" /> desse componente <see cref="T:System.Diagnostics.Process" /> e o associa ao componente.</summary>
        <returns><see langword="true" /> se um recurso de processo for iniciado, <see langword="false" /> se nenhum novo recurso de processo for iniciado (por exemplo, se um processo existente for reutilizado).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo e associá-lo a atual <xref:System.Diagnostics.Process> componente. O valor de retorno `true` indica que um novo recurso de processo foi iniciado. Se o recurso de processo especificado pela <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade já está em execução no computador, nenhum recurso de processo adicional será iniciado. Em vez disso, o processo em execução resource é reutilizado e `false` é retornado.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
> [!NOTE]
>  Se você estiver usando o Visual Studio, essa sobrecarga da <xref:System.Diagnostics.Process.Start%2A> método é aquele que você insere em seu código depois que você arrasta um <xref:System.Diagnostics.Process> componente para o designer. Use o `Properties` janela para expandir o `StartInfo` categoria e gravar o valor apropriado para o `FileName` propriedade. As alterações serão exibidas no formulário de `InitializeComponent` procedimento.  
  
 Essa sobrecarga de <xref:System.Diagnostics.Process.Start%2A> não é um `static` método. Você deverá chamá-la de uma instância da <xref:System.Diagnostics.Process> classe. Antes de chamar <xref:System.Diagnostics.Process.Start%2A>, você deve primeiro especificar <xref:System.Diagnostics.Process.StartInfo%2A> informações de propriedade para este <xref:System.Diagnostics.Process> instância, porque essa informação é usada para determinar o recurso de processo para iniciar.  
  
 As outras sobrecargas do <xref:System.Diagnostics.Process.Start%2A> método são `static` membros. Não é preciso criar uma instância da <xref:System.Diagnostics.Process> componente antes de chamar essas sobrecargas do método. Em vez disso, você pode chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> em si e uma nova classe <xref:System.Diagnostics.Process> componente é criado se o processo foi iniciado. Ou, `null` será retornado se um processo foi reutilizado. O recurso de processo é automaticamente associado ao novo <xref:System.Diagnostics.Process> componente que é retornado pelo <xref:System.Diagnostics.Process.Start%2A> método.  
  
 O <xref:System.Diagnostics.Process.StartInfo%2A> membros podem ser usados para duplicar a funcionalidade dos `Run` caixa de diálogo do Windows `Start` menu. Tudo o que pode ser digitado em uma linha de comando pode ser iniciado, definindo os valores apropriados <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. As únicas <xref:System.Diagnostics.Process.StartInfo%2A> propriedade que deve ser definida é o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisa ser um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se você tiver associado a arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Na linha de comando, você pode especificar ações a serem tomadas para determinados tipos de arquivos. Por exemplo, você pode imprimir documentos ou editar arquivos de texto. Especifique essas ações usando o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> membro o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade. Para outros tipos de arquivos, você pode especificar argumentos de linha de comando quando você inicia o arquivo a partir de `Run` caixa de diálogo. Por exemplo, você pode passar uma URL como um argumento, se você especificar que o seu navegador como o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>. Esses argumentos podem ser especificados na <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membro.  
  
 Se você tiver uma variável de caminho declarada em seu sistema, o uso de aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não está em seu caminho, e você adicioná-lo usando as aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente qualquer processo no `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de servidor e de página da Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto que o navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre estados de apartment em threads gerenciados é necessária aqui. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` sobre o `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` state ou colocar nas `MTA` de estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não ser `unknown`. Se o estado não é definido explicitamente, quando o aplicativo encontra um método desse tipo, o padrão será `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja gerada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir usa uma instância da <xref:System.Diagnostics.Process> classe iniciar um processo.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Não foi especificado nenhum nome de arquivo no <see cref="P:System.Diagnostics.Process.StartInfo" /> do componente <see cref="T:System.Diagnostics.Process" />.
-ou- O membro <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> da propriedade <see cref="P:System.Diagnostics.Process.StartInfo" /> é <see langword="true" /> enquanto <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> é <see langword="true" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Sistemas operacionais sem suporte para shell, como o Nano Server (somente .NET Core) não são compatíveis com o método.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (System.Diagnostics.ProcessStartInfo startInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(class System.Diagnostics.ProcessStartInfo startInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.Diagnostics.ProcessStartInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (startInfo As ProcessStartInfo) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::Diagnostics::ProcessStartInfo ^ startInfo);" />
      <MemberSignature Language="F#" Value="static member Start : System.Diagnostics.ProcessStartInfo -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start startInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="startInfo" Type="System.Diagnostics.ProcessStartInfo" />
      </Parameters>
      <Docs>
        <param name="startInfo">O <see cref="T:System.Diagnostics.ProcessStartInfo" /> que contém as informações usadas para iniciar o processo, incluindo o nome do arquivo e quaisquer argumentos de linha de comando.</param>
        <summary>Inicia o recurso de processo especificado pelo parâmetro que contém informações de início do processo (por exemplo, o nome do arquivo do processo a ser iniciado) e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo, especificando um <xref:System.Diagnostics.ProcessStartInfo> instância. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar é uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite que você inicie um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. Usar essa sobrecarga com um <xref:System.Diagnostics.ProcessStartInfo> parâmetro é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo suas <xref:System.Diagnostics.Process.StartInfo%2A> propriedades e chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Usando um <xref:System.Diagnostics.ProcessStartInfo> da instância como o parâmetro permite que você chame <xref:System.Diagnostics.Process.Start%2A> com mais controle sobre o que é passado para a chamada para iniciar o processo. Se você precisar passar um nome de arquivo ou um nome de arquivo e os argumentos, não é necessário criar um novo <xref:System.Diagnostics.ProcessStartInfo> da instância, embora isso seja uma opção. As únicas <xref:System.Diagnostics.Process.StartInfo%2A?displayProperty=nameWithType> propriedade que deve ser definida é o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. O <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão foi associada um aplicativo que é instalado no sistema. Por exemplo, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade pode ter uma extensão. txt se você tiver associado a arquivos de texto com um editor, como o bloco de notas, ou ele pode ter uma extensão. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word.  
  
 Você pode iniciar um aplicativo ClickOnce, especificando o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> propriedades da <xref:System.Diagnostics.Process.StartInfo%2A> instância estiverem definidas, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A?displayProperty=nameWithType> é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A?displayProperty=nameWithType> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden?displayProperty=nameWithType>. Se o <xref:System.Diagnostics.ProcessStartInfo.Domain%2A?displayProperty=nameWithType> é de propriedade `null`, o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> propriedade deve estar no formato UPN *usuário*@*DNS_domain_name*.   
  
 Ao contrário de outras sobrecargas, a sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que não tem nenhum parâmetro não é um `static` membro. Use a sobrecarga quando você já tiver criado uma <xref:System.Diagnostics.Process> da instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-la ao existente <xref:System.Diagnostics.Process> instância. Use um dos `static` sobrecarrega quando você deseja criar um novo <xref:System.Diagnostics.Process> componente em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique as informações de início para o recurso de processo usando um <xref:System.Diagnostics.ProcessStartInfo> instância.  
  
 Se você tiver uma variável de caminho declarada em seu sistema, o uso de aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não está em seu caminho, e você adicioná-lo usando as aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente qualquer processo no `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de servidor e de página da Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto que o navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre estados de apartment em threads gerenciados é necessária aqui. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o `startInfo` parâmetro, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` no `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` state ou colocar nas `MTA` de estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não ser `unknown`. Se o estado não é definido explicitamente, quando o aplicativo encontra um método desse tipo, o padrão será `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja gerada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele começa a algumas outras instâncias do Internet Explorer e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada ao navegar para um site específico.  
  
 Para obter exemplos adicionais de outros usos desse método, consulte as propriedades individuais do <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado na propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> do parâmetro <paramref name="startInfo" />.  
  
- ou - 
A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do parâmetro <paramref name="startInfo" /> é <see langword="true" /> e a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardInput" />, <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardOutput" /> ou <see cref="P:System.Diagnostics.ProcessStartInfo.RedirectStandardError" /> também é <see langword="true" />.  
  
- ou - 
A propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> do parâmetro <paramref name="startInfo" /> é <see langword="true" /> e a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.UserName" /> não é <see langword="null" /> ou está vazia ou a propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.Password" /> não é <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException">O parâmetro <paramref name="startInfo" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">O arquivo especificado na propriedade <see cref="P:System.Diagnostics.ProcessStartInfo.FileName" /> do parâmetro <paramref name="startInfo" /> não pôde ser encontrado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
- ou - 
A soma do comprimento dos argumentos e do comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: "A área de dados passada para uma chamada do sistema é muito pequena." ou “O acesso foi negado”.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Sistemas operacionais sem suporte para shell, como o Nano Server (somente .NET Core) não são compatíveis com o método.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="static member Start : string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo ou documento a ser executado no processo.</param>
        <summary>Inicia um recurso de processo especificando o nome de um arquivo de aplicativo ou documento e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo especificando seu nome de arquivo. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar é uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite que você inicie um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o `fileName` parâmetro para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Iniciar um processo, especificando seu nome de arquivo é semelhante ao digitar as informações de `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão tiver sido associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt, se você tiver associado a arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, na mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro para "Notepad.exe" ou "Notepad".  
  
 Essa sobrecarga não permite argumentos de linha de comando para o processo. Se você precisar especificar um ou mais argumentos de linha de comando para o processo, use o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29?displayProperty=nameWithType> ou <xref:System.Diagnostics.Process.Start%28System.String%2CSystem.String%29?displayProperty=nameWithType> sobrecargas.  
  
 Ao contrário de outras sobrecargas, a sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que não tem nenhum parâmetro não é um `static` membro. Use a sobrecarga quando você já tiver criado uma <xref:System.Diagnostics.Process> da instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-la ao existente <xref:System.Diagnostics.Process> instância. Use um dos `static` sobrecarrega quando você deseja criar um novo <xref:System.Diagnostics.Process> componente em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo de recurso do processo para iniciar.  
  
 Se você tiver uma variável de caminho declarada em seu sistema, o uso de aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não está em seu caminho, e você adicioná-lo usando as aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente qualquer processo no `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de servidor e de página da Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto que o navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade.  
  
 Uma observação sobre estados de apartment em threads gerenciados é necessária aqui. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` sobre o `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` state ou colocar nas `MTA` de estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não ser `unknown`. Se o estado não é definido explicitamente, quando o aplicativo encontra um método desse tipo, o padrão será `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja gerada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele começa a algumas outras instâncias do Internet Explorer e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada ao navegar para um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">A variável de ambiente PATH tem uma cadeia de caracteres que contém aspas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments);" />
      <MemberSignature Language="F#" Value="static member Start : string * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="arguments" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="arguments">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <summary>Inicia um recurso de processo especificando o nome de um aplicativo e um conjunto de argumentos de linha de comando e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para iniciar um recurso de processo, especificando seu nome de arquivo e argumentos de linha de comando. A sobrecarga associa o recurso a um novo <xref:System.Diagnostics.Process> objeto.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar é uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite que você inicie um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> e <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A> membros da <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Iniciar um processo, especificando seu nome de arquivo e os argumentos é semelhante ao digitar o nome de arquivo e os argumentos de linha de comando na `Run` caixa de diálogo do Windows `Start` menu. Portanto, o nome do arquivo não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão tiver sido associada com um aplicativo instalado no sistema. Por exemplo o nome do arquivo pode ter uma extensão. txt, se você tiver associado a arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, na mesma forma que o `Run` caixa de diálogo pode aceitar um nome de arquivo executável com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro para "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`. Se o `fileName` parâmetro representa um arquivo de comando (. cmd), o `arguments` parâmetro deve incluir um "`/c`"ou"`/k`" argumento para especificar se a janela de comando é encerrado ou continua após a conclusão.  
  
 Ao contrário de outras sobrecargas, a sobrecarga de <xref:System.Diagnostics.Process.Start%2A> que não tem nenhum parâmetro não é um `static` membro. Use a sobrecarga quando você já tiver criado uma <xref:System.Diagnostics.Process> da instância, informações de início especificada (incluindo o nome do arquivo) e deseja iniciar um recurso de processo e associá-la ao existente <xref:System.Diagnostics.Process> instância. Use um dos `static` sobrecarrega quando você deseja criar um novo <xref:System.Diagnostics.Process> componente em vez de iniciar um processo para um componente existente. Essa sobrecarga e a sobrecarga que não tem parâmetros permitem que você especifique o nome do arquivo do recurso de processo para iniciar e argumentos de linha de comando para passar.  
  
 Se você tiver uma variável de caminho declarada em seu sistema, o uso de aspas, você deve qualificar totalmente esse caminho ao iniciar qualquer processo encontrado nesse local. Caso contrário, o sistema não localizará o caminho. Por exemplo, se `c:\mypath` não está em seu caminho, e você adicioná-lo usando as aspas: `path = %path%;"c:\mypath"`, você deve qualificar totalmente qualquer processo no `c:\mypath` ao iniciá-lo.  
  
> [!NOTE]
>  Código de controle de servidor e de página da Web do ASP.NET é executado no contexto do processo de trabalho do ASP.NET no servidor Web.  Se você usar o <xref:System.Diagnostics.Process.Start%2A> método em uma página da Web ASP.NET ou controle de servidor, o novo processo é executado no servidor Web com permissões restritas. O processo não inicia no mesmo contexto que o navegador do cliente e não tem acesso à área de trabalho do usuário.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade. 
  
 Uma observação sobre estados de apartment em threads gerenciados é necessária aqui. Quando <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> é `true` sobre o componente do processo <xref:System.Diagnostics.Process.StartInfo%2A> propriedade, verifique se você tiver definido um modelo de threading no seu aplicativo, definindo o atributo `[STAThread]` sobre o `main()` método. Caso contrário, um thread gerenciado pode estar em um `unknown` state ou colocar nas `MTA` de estado, o que está em conflito com o último <xref:System.Diagnostics.ProcessStartInfo.UseShellExecute%2A> sendo `true`. Alguns métodos requerem que o estado de apartment não ser `unknown`. Se o estado não é definido explicitamente, quando o aplicativo encontra um método desse tipo, o padrão será `MTA`, uma vez definido, o estado de apartment não pode ser alterada. No entanto, `MTA` faz com que uma exceção seja gerada quando o shell do sistema operacional está gerenciando o thread.  
  
   
  
## Examples  
 O exemplo a seguir primeiro gera uma instância do Internet Explorer e exibe o conteúdo da pasta Favoritos no navegador. Ele começa a algumas outras instâncias do Internet Explorer e exibe algumas páginas específicas ou sites. Por fim, ele inicia o Internet Explorer com a janela que está sendo minimizada ao navegar para um site específico.  
  
 [!code-cpp[Process.Start_static#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_static/CPP/processstartstatic.cpp#1)]
 [!code-csharp[Process.Start_static#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_static/CS/processstartstatic.cs#1)]
 [!code-vb[Process.Start_static#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_static/VB/processstartstatic.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O parâmetro <paramref name="fileName" /> ou <paramref name="arguments" /> é <see langword="null" />.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
- ou - 
A soma do comprimento dos argumentos e do comprimento do caminho completo para o processo excede 2080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: "A área de dados passada para uma chamada do sistema é muito pequena." ou “O acesso foi negado”.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.IO.FileNotFoundException">A variável de ambiente PATH tem uma cadeia de caracteres que contém aspas.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
        <altmember cref="P:System.Diagnostics.Process.StartInfo" />
        <altmember cref="T:System.Diagnostics.ProcessStartInfo" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="userName">O nome de usuário a ser usado ao iniciar o processo.</param>
        <param name="password">Um <see cref="T:System.Security.SecureString" /> que contém a senha a ser usada ao iniciar o processo.</param>
        <param name="domain">O domínio a ser usado ao iniciar o processo.</param>
        <summary>Inicia um recurso de processo, especificando o nome de um aplicativo, um nome de usuário, uma senha e um domínio e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e thread primário, especificando seu nome de arquivo, nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um uniform resource identifier (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar é uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite que você inicie um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamar <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, na mesma forma que o **executados** caixa de diálogo pode aceitar um nome de arquivo executável com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro para "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável na <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade. 
  
   
  
## Examples  
 O exemplo de código a seguir mostra o uso dessa sobrecarga para iniciar um arquivo executável e também demonstra a geração de um <xref:System.ComponentModel.Win32Exception> quando é feita uma tentativa de iniciar um aplicativo associado a um arquivo não executável.  
  
 [!code-csharp[System.Diagnostics.Process.Start#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/CS/program.cs#1)]
 [!code-vb[System.Diagnostics.Process.Start#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Diagnostics.Process.Start/VB/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Erro ao abrir o arquivo associado.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux ou macOS (somente .NET Core) não é compatível com o método.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public static System.Diagnostics.Process Start (string fileName, string arguments, string userName, System.Security.SecureString password, string domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Diagnostics.Process Start(string fileName, string arguments, string userName, class System.Security.SecureString password, string domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.Start(System.String,System.String,System.String,System.Security.SecureString,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Start (fileName As String, arguments As String, userName As String, password As SecureString, domain As String) As Process" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Diagnostics::Process ^ Start(System::String ^ fileName, System::String ^ arguments, System::String ^ userName, System::Security::SecureString ^ password, System::String ^ domain);" />
      <MemberSignature Language="F#" Value="static member Start : string * string * string * System.Security.SecureString * string -&gt; System.Diagnostics.Process" Usage="System.Diagnostics.Process.Start (fileName, arguments, userName, password, domain)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Process</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="arguments" Type="System.String" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="userName" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="password" Type="System.Security.SecureString" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="domain" Type="System.String" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="fileName">O nome de um arquivo de aplicativo a ser executado no processo.</param>
        <param name="arguments">Argumentos de linha de comando a serem passados durante o início do processo.</param>
        <param name="userName">O nome de usuário a ser usado ao iniciar o processo.</param>
        <param name="password">Um <see cref="T:System.Security.SecureString" /> que contém a senha a ser usada ao iniciar o processo.</param>
        <param name="domain">O domínio a ser usado ao iniciar o processo.</param>
        <summary>Inicia um recurso de processo, especificando o nome de um aplicativo, um conjunto de argumentos de linha de comando, um nome de usuário, uma senha e um domínio e associa o recurso a um novo componente <see cref="T:System.Diagnostics.Process" />.</summary>
        <returns>Um novo <see cref="T:System.Diagnostics.Process" /> associado ao recurso do processo, ou <see langword="null" />, se nenhum recurso do processo tiver sido iniciado. Observe que um novo processo iniciado junto com instâncias já em execução do mesmo processo será independente dos outros. Além disso, Iniciar poderá retornar um Processo não nulo com a propriedade <see cref="P:System.Diagnostics.Process.HasExited" /> já definida como <see langword="true" />. Nesse caso, o processo iniciado pode ter ativado uma instância existente de si próprio e fechado em seguida.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use essa sobrecarga para criar um novo processo e thread primário especificando o nome do arquivo, argumentos de linha de comando, nome de usuário, senha e domínio. O novo processo, em seguida, executa o arquivo executável especificado no contexto de segurança as credenciais especificadas (usuário, domínio e senha).  
  
> [!NOTE]
>  Quando o arquivo executável está localizado em uma unidade remota, você deve identificar o compartilhamento de rede usando um uniform resource identifier (URI), não uma letra de unidade vinculado.  
  
> [!NOTE]
>  Se o endereço do arquivo executável para iniciar é uma URL, o processo não é iniciado e `null` é retornado.  
  
 Essa sobrecarga permite que você inicie um processo sem primeiro criar um novo <xref:System.Diagnostics.Process> instância. A sobrecarga é uma alternativa às etapas explícitas de criação de um novo <xref:System.Diagnostics.Process> instância, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Arguments%2A>, <xref:System.Diagnostics.ProcessStartInfo.UserName%2A>, <xref:System.Diagnostics.ProcessStartInfo.Password%2A>, e <xref:System.Diagnostics.ProcessStartInfo.Domain%2A> propriedades do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade e chamada <xref:System.Diagnostics.Process.Start%2A> para o <xref:System.Diagnostics.Process> instância.  
  
 Da mesma forma, na mesma forma que o **executados** caixa de diálogo pode aceitar um nome de arquivo executável com ou sem a extensão .exe, a extensão .exe é opcional no `fileName` parâmetro. Por exemplo, você pode definir o `fileName` parâmetro para "Notepad.exe" ou "Notepad". Se o `fileName` parâmetro representa um arquivo executável, o `arguments` parâmetro pode representar um arquivo para agir como o arquivo de texto em `Notepad.exe myfile.txt`.  
  
> [!NOTE]
>  O nome do arquivo deve representar um arquivo executável na <xref:System.Diagnostics.Process.Start%2A> sobrecargas que têm `userName`, `password`, e `domain` parâmetros.  
  
 Sempre que você usar <xref:System.Diagnostics.Process.Start%2A> para iniciar um processo, talvez seja necessário fechá-lo ou o risco de perda de recursos do sistema. Fechados processos usando <xref:System.Diagnostics.Process.CloseMainWindow%2A> ou <xref:System.Diagnostics.Process.Kill%2A>. Você pode verificar se um processo já foi fechado usando seu <xref:System.Diagnostics.Process.HasExited%2A> propriedade. 
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Nenhum nome de arquivo foi especificado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro ao abrir o arquivo associado.  
  
- ou - 
A soma do tamanho dos argumentos e o tamanho do caminho completo para o arquivo associado excede 2.080. A mensagem de erro associada a essa exceção pode ser uma das seguintes: "A área de dados passada para uma chamada do sistema é muito pequena." ou “O acesso foi negado”.</exception>
        <exception cref="T:System.ObjectDisposedException">O objeto do processo já foi descartado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Linux ou macOS (somente .NET Core) não é compatível com o método.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="StartInfo">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessStartInfo StartInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessStartInfo StartInfo" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property StartInfo As ProcessStartInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessStartInfo ^ StartInfo { System::Diagnostics::ProcessStartInfo ^ get(); void set(System::Diagnostics::ProcessStartInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.StartInfo : System.Diagnostics.ProcessStartInfo with get, set" Usage="System.Diagnostics.Process.StartInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Content)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("Specifies information used to start a process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartInfo")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessStartInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define as propriedades a serem passadas para o método <see cref="M:System.Diagnostics.Process.Start" /> do <see cref="T:System.Diagnostics.Process" />.</summary>
        <value>O <see cref="T:System.Diagnostics.ProcessStartInfo" /> que representa os dados com os quais o processo será iniciado. Esses argumentos incluem o nome do documento ou arquivo executável usado para iniciar o processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.StartInfo%2A> representa o conjunto de parâmetros a serem usados para iniciar um processo. Quando <xref:System.Diagnostics.Process.Start%2A> é chamado, o <xref:System.Diagnostics.Process.StartInfo%2A> é usado para especificar o processo para iniciar. Somente necessário <xref:System.Diagnostics.Process.StartInfo%2A> membro a ser definido é o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade. Iniciar um processo, especificando o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade é semelhante de digitar as informações a **execute** caixa de diálogo do Windows **iniciar** menu. Portanto, o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisa representar um arquivo executável. Ele pode ser de qualquer tipo de arquivo para o qual a extensão tiver sido associada com um aplicativo instalado no sistema. Por exemplo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> pode ter uma extensão. txt, se você tiver associado a arquivos de texto com um editor, como o bloco de notas, ou ele pode ter um. doc, se você tiver arquivos associated.doc com uma ferramenta de processamento de texto, como o Microsoft Word. Da mesma forma, na mesma forma que o **executados** caixa de diálogo pode aceitar um nome de arquivo executável com ou sem a extensão .exe, a extensão .exe é opcional no <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade como "Notepad.exe" ou "Notepad".  
  
 Você pode iniciar um aplicativo ClickOnce, definindo o <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade para o local (por exemplo, um endereço da Web) do qual você instalou o aplicativo. Não inicie um aplicativo ClickOnce, especificando seu local de instalação no disco rígido.  
  
 Se o nome do arquivo envolve um arquivo não executável, como um arquivo. doc, você pode incluir um verbo especificando qual ação será tomada no arquivo. Por exemplo, você pode definir o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> como "Print" para um arquivo terminando na extensão. doc. O nome de arquivo especificado na <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade não precisa ter uma extensão, se você inserir manualmente um valor para o <xref:System.Diagnostics.ProcessStartInfo.Verb%2A> propriedade. No entanto, se você usar o <xref:System.Diagnostics.ProcessStartInfo.Verbs%2A> propriedade para determinar quais verbos estão disponíveis, você deve incluir a extensão.  
  
 Você pode alterar os parâmetros especificados na <xref:System.Diagnostics.Process.StartInfo%2A> propriedade até o momento em que você chamar o <xref:System.Diagnostics.Process.Start%2A> método sobre o processo. Depois de iniciar o processo, alterando o <xref:System.Diagnostics.Process.StartInfo%2A> valores não afeta nem reinicie o processo associado. Se você chamar o <xref:System.Diagnostics.Process.Start%28System.Diagnostics.ProcessStartInfo%29> método com o <xref:System.Diagnostics.ProcessStartInfo.UserName%2A?displayProperty=nameWithType> e <xref:System.Diagnostics.ProcessStartInfo.Password%2A?displayProperty=nameWithType> conjunto de propriedades, não gerenciado `CreateProcessWithLogonW` função é chamada, que inicia o processo de uma nova janela, mesmo se o <xref:System.Diagnostics.ProcessStartInfo.CreateNoWindow%2A> é o valor da propriedade `true` ou o <xref:System.Diagnostics.ProcessStartInfo.WindowStyle%2A> é o valor da propriedade <xref:System.Diagnostics.ProcessWindowStyle.Hidden>.  
  
 Se você não tiver usado o <xref:System.Diagnostics.Process.Start%2A> método para iniciar um processo, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade não reflete os parâmetros usados para iniciar o processo. Por exemplo, se você usar <xref:System.Diagnostics.Process.GetProcesses%2A> para obter uma matriz de processos em execução no computador, o <xref:System.Diagnostics.Process.StartInfo%2A> propriedade de cada <xref:System.Diagnostics.Process> não contém o nome do arquivo original ou os argumentos usados para iniciar o processo.  
  
 Quando o processo é iniciado, o nome do arquivo é o arquivo que preenche a (somente leitura) <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você quiser recuperar o arquivo executável que está associado com o processo depois que o processo foi iniciado, use o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Se você quiser definir um arquivo executável de um <xref:System.Diagnostics.Process> instância para que um processo associado não foi iniciado, use o <xref:System.Diagnostics.Process.StartInfo%2A> da propriedade <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> membro. Porque os membros do <xref:System.Diagnostics.Process.StartInfo%2A> propriedade são os argumentos que são passados para o <xref:System.Diagnostics.Process.Start%2A> método de um processo, alterando a <xref:System.Diagnostics.ProcessStartInfo.FileName%2A> propriedade depois de iniciado o processo associado não redefinirão o <xref:System.Diagnostics.Process.MainModule%2A> propriedade. Essas propriedades são usadas somente para inicializar o processo associado.  
  
   
  
## Examples  
 O exemplo a seguir preenche uma <xref:System.Diagnostics.Process.StartInfo%2A> com o arquivo a ser executado, a ação executada nele e se ele deve exibe uma interface do usuário. Para obter exemplos adicionais, consulte as páginas de referência para as propriedades do <xref:System.Diagnostics.ProcessStartInfo> classe.  
  
 [!code-cpp[Process.Start_instance#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process.Start_instance/CPP/processstart.cpp#1)]
 [!code-csharp[Process.Start_instance#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process.Start_instance/CS/processstart.cs#1)]
 [!code-vb[Process.Start_instance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process.Start_instance/VB/processstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">O valor que especifica o <see cref="P:System.Diagnostics.Process.StartInfo" /> é <see langword="null" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="P:System.Diagnostics.ProcessStartInfo.FileName" />
      </Docs>
    </Member>
    <Member MemberName="StartTime">
      <MemberSignature Language="C#" Value="public DateTime StartTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime StartTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.StartTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property StartTime As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime StartTime { DateTime get(); };" />
      <MemberSignature Language="F#" Value="member this.StartTime : DateTime" Usage="System.Diagnostics.Process.StartTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The time at which the process was started.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessStartTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a hora em que o processo associado foi iniciado.</summary>
        <value>Um objeto que indica quando o processo é iniciado. Uma exceção é lançada se o processo não está em execução.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.StartTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.InvalidOperationException">O processo foi encerrado.  
  
- ou - 
O processo não foi iniciado.</exception>
        <exception cref="T:System.ComponentModel.Win32Exception">Ocorreu um erro na chamada para a função do Windows.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="SynchronizingObject">
      <MemberSignature Language="C#" Value="public System.ComponentModel.ISynchronizeInvoke SynchronizingObject { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.ISynchronizeInvoke SynchronizingObject" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.SynchronizingObject" />
      <MemberSignature Language="VB.NET" Value="Public Property SynchronizingObject As ISynchronizeInvoke" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::ComponentModel::ISynchronizeInvoke ^ SynchronizingObject { System::ComponentModel::ISynchronizeInvoke ^ get(); void set(System::ComponentModel::ISynchronizeInvoke ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SynchronizingObject : System.ComponentModel.ISynchronizeInvoke with get, set" Usage="System.Diagnostics.Process.SynchronizingObject" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The object used to marshal the event handler calls issued as a result of a Process exit.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessSynchronizingObject")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.ISynchronizeInvoke</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém ou define o objeto usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento de encerramento de um processo.</summary>
        <value>O <see cref="T:System.ComponentModel.ISynchronizeInvoke" /> usado para realizar marshaling das chamadas do manipulador de eventos emitidas como resultado de um evento <see cref="E:System.Diagnostics.Process.Exited" /> no processo.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quando <xref:System.Diagnostics.EventLog.SynchronizingObject%2A> está `null`, métodos que manipulam o <xref:System.Diagnostics.Process.Exited> eventos são chamados em um thread do pool de threads do sistema. Para obter mais informações sobre pools de threads do sistema, consulte <xref:System.Threading.ThreadPool>.  
  
 Quando o <xref:System.Diagnostics.Process.Exited> evento é manipulado por um componente de Windows Forms visual, como um <xref:System.Windows.Forms.Button>, acessando o componente através do pool de threads do sistema pode não funcionar ou pode resultar em uma exceção. Evitar isso, definindo <xref:System.Diagnostics.Process.SynchronizingObject%2A> a um componente de Windows Forms, que faz com que os métodos de tratamento de <xref:System.Diagnostics.Process.Exited> evento a ser chamado no mesmo thread em que o componente foi criado.  
  
 Se o <xref:System.Diagnostics.Process> é usado dentro de [!INCLUDE[vsprvslong](~/includes/vsprvslong-md.md)] em um designer de formulários do Windows <xref:System.Diagnostics.Process.SynchronizingObject%2A> é definida automaticamente como o controle que contém o <xref:System.Diagnostics.Process>. Por exemplo, se você colocar uma <xref:System.Diagnostics.Process> em um designer para `Form1` (que herda do <xref:System.Windows.Forms.Form>) a <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade de <xref:System.Diagnostics.Process> é definido como a instância do `Form1`:  
  
 [!code-cpp[Process_SynchronizingObject#2](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/remarks.cpp#2)]
 [!code-csharp[Process_SynchronizingObject#2](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/remarks.cs#2)]
 [!code-vb[Process_SynchronizingObject#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/remarks.vb#2)]  
  
 Normalmente, essa propriedade é definida quando o componente é colocado dentro um controle ou formulário, porque esses componentes são associados a um thread específico.  
  
   
  
## Examples  
 [!code-cpp[Process_SynchronizingObject#1](~/samples/snippets/cpp/VS_Snippets_CLR/Process_SynchronizingObject/CPP/process_synchronizingobject.cpp#1)]
 [!code-csharp[Process_SynchronizingObject#1](~/samples/snippets/csharp/VS_Snippets_CLR/Process_SynchronizingObject/CS/process_synchronizingobject.cs#1)]
 [!code-vb[Process_SynchronizingObject#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Process_SynchronizingObject/VB/process_synchronizingobject.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <Member MemberName="Threads">
      <MemberSignature Language="C#" Value="public System.Diagnostics.ProcessThreadCollection Threads { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Diagnostics.ProcessThreadCollection Threads" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.Threads" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Threads As ProcessThreadCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Diagnostics::ProcessThreadCollection ^ Threads { System::Diagnostics::ProcessThreadCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Threads : System.Diagnostics.ProcessThreadCollection" Usage="System.Diagnostics.Process.Threads" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The number of threads of this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessThreads")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.ProcessThreadCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o conjunto de threads que estão em execução no processo associado.</summary>
        <value>Uma matriz do tipo <see cref="T:System.Diagnostics.ProcessThread" /> que representa o sistema operacional de threads em execução no processo associado no momento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um thread executa código em um processo. Cada processo é iniciado com um único thread, seu thread primário. Qualquer thread pode criar threads adicionais. Threads dentro de um processo compartilham o espaço de endereço do processo.  
  
 Use <xref:System.Diagnostics.ProcessThread> para obter todos os threads associados com o processo atual. O thread primário não é necessariamente no índice zero na matriz.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.SystemException">O processo não tem um <see cref="P:System.Diagnostics.Process.Id" /> ou nenhum processo está associado à instância <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
O processo associado foi encerrado.</exception>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me); defina a <see cref="P:System.Diagnostics.ProcessStartInfo.UseShellExecute" /> como <see langword="false" /> para acessar essa propriedade no Windows 98 e no Windows Me.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="T:System.Diagnostics.ProcessThread" />
        <altmember cref="P:System.Diagnostics.Process.BasePriority" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="process.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Formata o nome do processo como uma cadeia de caracteres, combinada com o tipo de componente pai, se aplicável.</summary>
        <returns>O <see cref="P:System.Diagnostics.Process.ProcessName" />, combinado com o valor retornado <see cref="M:System.Object.ToString" /> do componente base.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><see cref="M:System.Diagnostics.Process.ToString" /> não é compatível com Windows 98.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
      </Docs>
    </Member>
    <Member MemberName="TotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan TotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan TotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.TotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan TotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.TotalProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.TotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process has used.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessTotalProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador total para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica o tempo que o processo associado passou utilizando a CPU. Esse valor é a soma de <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> e <see cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.TotalProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="UserProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan UserProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan UserProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.UserProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UserProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan UserProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.UserProcessorTime : TimeSpan" Usage="System.Diagnostics.Process.UserProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of CPU time the process spent outside the operating system core.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessUserProcessorTime")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tempo de processador do usuário para esse processo.</summary>
        <value>Um <see cref="T:System.TimeSpan" /> que indica a quantidade de tempo que o processo associado gastou executando o código dentro da porção de aplicativo do processo (e não dentro do núcleo do sistema operacional).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <exception cref="T:System.NotSupportedException">Você está tentando acessar a propriedade <see cref="P:System.Diagnostics.Process.UserProcessorTime" /> para um processo que está sendo executado em um computador remoto. Essa propriedade está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.UserProcessorTime" />
        <altmember cref="P:System.Diagnostics.Process.PrivilegedProcessorTime" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize">
      <MemberSignature Language="C#" Value="public int VirtualMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VirtualMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int VirtualMemorySize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize : int" Usage="System.Diagnostics.Process.VirtualMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use VirtualMemorySize64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.VirtualMemorySize64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o tamanho da memória virtual do processo, em bytes.</summary>
        <value>A quantidade de memória virtual, em bytes, que o processo associado solicitou.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.VirtualMemorySize64" />
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <Member MemberName="VirtualMemorySize64">
      <MemberSignature Language="C#" Value="public long VirtualMemorySize64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 VirtualMemorySize64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property VirtualMemorySize64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long VirtualMemorySize64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.VirtualMemorySize64 : int64" Usage="System.Diagnostics.Process.VirtualMemorySize64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of virtual memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessVirtualMemorySize")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória virtual, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória virtual, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual de memória virtual usada pelo processo, em bytes. O sistema operacional é mapeado para o espaço de endereço virtual para cada processo para páginas carregada na memória física, ou para páginas armazenadas no arquivo de paginação de memória virtual no disco.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente a **Bytes virtuais** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.PeakVirtualMemorySize64" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForExit">
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Define o período de tempo a esperar para o processo associado sair e bloqueia o thread atual de execução até que o tempo tenha passado ou o processo tenha sido encerrado. Para evitar o bloqueio do thread atual, use o evento <see cref="E:System.Diagnostics.Process.Exited" />.  
  
Para obter exemplos de código, consulte <see cref="P:System.Diagnostics.Process.StandardError" /> e as páginas de referência de propriedade <see cref="P:System.Diagnostics.Process.ExitCode" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public void WaitForExit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WaitForExit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit" />
      <MemberSignature Language="VB.NET" Value="Public Sub WaitForExit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WaitForExit();" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : unit -&gt; unit" Usage="process.WaitForExit " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Instrui o componente <see cref="T:System.Diagnostics.Process" /> a esperar indefinidamente que o processo associado seja encerrado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit> faz com que o thread atual Aguarde até que o processo associado seja encerrado.  Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o evento <xref:System.Diagnostics.Process.Exited>.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente espera uma quantidade infinita de tempo para os manipuladores de eventos e o processo sair. Isso pode causar um aplicativo parar de responder. Por exemplo, se você chamar <xref:System.Diagnostics.Process.CloseMainWindow%2A> para um processo que tenha uma interface de usuário, a solicitação para o sistema operacional para encerrar o processo associado pode não ser manipulada se o processo é escrito nunca inserir seu loop de mensagem.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não por tempo indeterminado. Além disso, as versões anteriores não aguardou os manipuladores de eventos sair se completo <xref:System.Int32.MaxValue> tempo foi atingido.  
  
 Essa sobrecarga garante que todo o processamento foi concluída, incluindo a manipulação de eventos assíncronos para saída padrão redirecionado. Você deve usar essa sobrecarga após uma chamada para o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga quando a saída padrão foi redirecionada para manipuladores de eventos assíncronos.  
  
 Quando um processo associado sair (ou seja, quando ele é desligado por sistema operacional por meio de um encerramento anormal ou normal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que tivesse chamado <xref:System.Diagnostics.Process.WaitForExit>. O <xref:System.Diagnostics.Process> componente, em seguida, pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta mais para um recurso de processo existente. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerrada processos que não foram liberados pela <xref:System.Diagnostics.Process> componentes, para que ele mantém os <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chame <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> da instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi encerrado e você não precisa mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A> libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte a seção de comentários do <xref:System.Diagnostics.Process.StandardError%2A> página de referência de propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível acessar a configuração de espera.</exception>
        <exception cref="T:System.SystemException">Nenhum processo <see cref="P:System.Diagnostics.Process.Id" /> foi definido e não existe um <see cref="P:System.Diagnostics.Process.Handle" /> do qual a propriedade <see cref="P:System.Diagnostics.Process.Id" /> possa ser determinada.  
  
- ou - 
Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Você está tentando chamar <see cref="M:System.Diagnostics.Process.WaitForExit" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
      </Docs>
    </Member>
    <Member MemberName="WaitForExit">
      <MemberSignature Language="C#" Value="public bool WaitForExit (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForExit(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForExit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForExit (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForExit(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForExit : int -&gt; bool" Usage="process.WaitForExit milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="milliseconds">O tempo, em milissegundos, a aguardar até que o processo seja encerrado. O máximo é o maior valor possível de um inteiro de 32 bits, que representa o infinito para o sistema operacional.</param>
        <summary>Instrui o componente <see cref="T:System.Diagnostics.Process" /> a aguardar o número especificado de milissegundos para que o processo associado seja encerrado.</summary>
        <returns><see langword="true" /> se o processo associado tiver sido encerrado; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> faz com que o thread atual Aguarde até que o processo associado seja encerrado. Ele deve ser chamado depois que todos os outros métodos são chamados no processo. Para evitar o bloqueio do thread atual, use o evento <xref:System.Diagnostics.Process.Exited>.  
  
 Esse método instrui o <xref:System.Diagnostics.Process> componente espera uma quantidade finita de tempo para que o processo seja encerrado. Se o processo associado não é encerrado no final do intervalo de porque a solicitação de encerramento é negada, `false` é retornada ao procedimento de chamada. Você pode especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para `milliseconds`, e <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29?displayProperty=nameWithType> se comportará como o <xref:System.Diagnostics.Process.WaitForExit> de sobrecarga. Se você passar 0 (zero) para o método, ele retorna `true` somente se o processo já tiver sido encerrado; caso contrário, ele retorna imediatamente `false`.  
  
> [!NOTE]
>  No [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] e versões anteriores, se `milliseconds` era – 1, o <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29> sobrecarga aguardou <xref:System.Int32.MaxValue> milissegundos (aproximadamente 24 dias), não por tempo indeterminado.  
  
 Quando a saída padrão foi redirecionada para manipuladores de eventos assíncronos, é possível que o processamento de saída não tenha concluído quando este método retorna. Para garantir que a manipulação assíncrona de eventos foi concluída, chame o <xref:System.Diagnostics.Process.WaitForExit> sobrecarga que não utiliza nenhum parâmetro depois de receber um `true` dessa sobrecarga. Para ajudar a garantir que o <xref:System.Diagnostics.Process.Exited> evento é manipulado corretamente em aplicativos do Windows Forms, defina o <xref:System.Diagnostics.Process.SynchronizingObject%2A> propriedade.  
  
 Quando um processo associado sair (for desligado pelo sistema operacional por meio de um encerramento anormal ou normal), o sistema armazena informações administrativas sobre o processo e retorna para o componente que tivesse chamado <xref:System.Diagnostics.Process.WaitForExit%28System.Int32%29>. O <xref:System.Diagnostics.Process> componente, em seguida, pode acessar as informações, que incluem o <xref:System.Diagnostics.Process.ExitTime%2A>, usando o <xref:System.Diagnostics.Process.Handle%2A> ao processo encerrado.  
  
 Porque o processo associado foi encerrado, o <xref:System.Diagnostics.Process.Handle%2A> propriedade do componente não aponta mais para um recurso de processo existente. Em vez disso, o identificador pode ser usado somente para acessar informações do sistema operacional sobre o recurso de processo. O sistema está ciente das alças para encerrada processos que não foram liberados pela <xref:System.Diagnostics.Process> componentes, para que ele mantém os <xref:System.Diagnostics.Process.ExitTime%2A> e <xref:System.Diagnostics.Process.Handle%2A> informações na memória até que o <xref:System.Diagnostics.Process> componente especificamente libera os recursos. Por esse motivo, sempre que você chame <xref:System.Diagnostics.Process.Start%2A> para um <xref:System.Diagnostics.Process> da instância, chame <xref:System.Diagnostics.Process.Close%2A> quando o processo associado foi encerrado e você não precisa mais qualquer informação administrativa sobre ele. <xref:System.Diagnostics.Process.Close%2A> libera a memória alocada para o processo encerrado.  
  
   
  
## Examples  
 Consulte o exemplo de código para o <xref:System.Diagnostics.Process.ExitCode%2A> propriedade.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.Win32Exception">Não foi possível acessar a configuração de espera.</exception>
        <exception cref="T:System.SystemException">Nenhum processo <see cref="P:System.Diagnostics.Process.Id" /> foi definido e não existe um <see cref="P:System.Diagnostics.Process.Handle" /> do qual a propriedade <see cref="P:System.Diagnostics.Process.Id" /> possa ser determinada.  
  
- ou - 
Não há processos associados a esse objeto <see cref="T:System.Diagnostics.Process" />.  
  
- ou - 
Você está tentando chamar <see cref="M:System.Diagnostics.Process.WaitForExit(System.Int32)" /> para um processo em execução em um computador remoto. Esse método está disponível somente para processos em execução no computador local.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="milliseconds" /> é um número negativo diferente de -1, que representa um tempo limite infinito.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
        <altmember cref="M:System.Diagnostics.Process.Kill" />
        <altmember cref="P:System.Diagnostics.Process.Handle" />
        <altmember cref="P:System.Diagnostics.Process.ExitTime" />
        <altmember cref="P:System.Diagnostics.Process.EnableRaisingEvents" />
        <altmember cref="P:System.Diagnostics.Process.HasExited" />
        <altmember cref="E:System.Diagnostics.Process.Exited" />
        <altmember cref="P:System.Diagnostics.Process.SynchronizingObject" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForInputIdle">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Faz com que o componente <see cref="T:System.Diagnostics.Process" /> aguarde até o processo associado entrar em um estado ocioso.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle();" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : unit -&gt; bool" Usage="process.WaitForInputIdle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Faz com que o componente <see cref="T:System.Diagnostics.Process" /> aguarde por tempo indefinido até que o processo associado entre em um estado ocioso. Essa sobrecarga se aplica apenas a processos com uma interface do usuário e, portanto, um loop de mensagem.</summary>
        <returns><see langword="true" /> se o processo associado tiver atingido um estado ocioso.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle> para forçar o processamento de seu aplicativo espere até que o loop de mensagem foi retornado para o estado ocioso. Quando um processo com uma interface do usuário está em execução, o seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. O processo, em seguida, retorna para o loop de mensagem. Um processo deve estar no estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar por um processo de partida terminar de criar a janela principal antes que o aplicativo se comunica com essa janela.  
  
 Se um processo não tem um loop de mensagem <xref:System.Diagnostics.Process.WaitForInputIdle> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle> sobrecarga instrui o <xref:System.Diagnostics.Process> componente para aguardar indefinidamente para o processo fique ocioso no loop de mensagem. Essa instrução pode fazer com que um aplicativo parar de responder. Por exemplo, se o processo é escrito para sempre sair seu loop de mensagem imediatamente, como no fragmento de código `while(true)`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem uma interface gráfica.  
  
- ou - 
Erro desconhecido. O processo não conseguiu entrar em um estado ocioso.  
  
- ou - 
O processo já terminou.  
  
- ou - 
Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WaitForInputIdle">
      <MemberSignature Language="C#" Value="public bool WaitForInputIdle (int milliseconds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool WaitForInputIdle(int32 milliseconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Process.WaitForInputIdle(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function WaitForInputIdle (milliseconds As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool WaitForInputIdle(int milliseconds);" />
      <MemberSignature Language="F#" Value="member this.WaitForInputIdle : int -&gt; bool" Usage="process.WaitForInputIdle milliseconds" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="milliseconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="milliseconds">Um valor de 1 para <see cref="F:System.Int32.MaxValue" />, que especifica o tempo, em milissegundos, a aguardar até que o processo associado entre em um estado ocioso. Um valor de 0 especifica um retorno imediato e um valor de -1 especifica uma espera infinita.</param>
        <summary>Faz com que o componente <see cref="T:System.Diagnostics.Process" /> a aguarde o número especificado de milissegundos para que o processo entre em um estado ocioso. Essa sobrecarga se aplica apenas a processos com uma interface do usuário e, portanto, um loop de mensagem.</summary>
        <returns><see langword="true" /> se o processo associado tiver atingido um estado ocioso; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Use <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> para forçar o processamento de seu aplicativo espere até que o loop de mensagem foi retornado para o estado ocioso. Quando um processo com uma interface do usuário está em execução, o seu loop de mensagem executado sempre que uma mensagem do Windows é enviada para o processo pelo sistema operacional. O processo, em seguida, retorna para o loop de mensagem. Um processo deve estar no estado ocioso quando ele está aguardando mensagens dentro de um loop de mensagem. Esse estado é útil, por exemplo, quando seu aplicativo precisa esperar por um processo de partida terminar de criar a janela principal antes que o aplicativo se comunica com essa janela.  
  
 Se um processo não tem um loop de mensagem <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> lança um <xref:System.InvalidOperationException>.  
  
 O <xref:System.Diagnostics.Process.WaitForInputIdle%28System.Int32%29> sobrecarga instrui o <xref:System.Diagnostics.Process> componente espera uma quantidade finita de tempo para o processo fique ocioso no loop de mensagem. Se o processo associado não ficou ocioso até o final do intervalo porque o loop ainda está processando mensagens, `false` é retornada ao procedimento de chamada.  
  
 Para obter mais informações sobre como manipular eventos, consulte [tratando e gerando eventos](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">O processo não tem uma interface gráfica.  
  
- ou - 
Erro desconhecido. O processo não conseguiu entrar em um estado ocioso.  
  
- ou - 
O processo já terminou.  
  
- ou - 
Nenhum processo está associado a esse objeto <see cref="T:System.Diagnostics.Process" />.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="M:System.Diagnostics.Process.Start" />
        <altmember cref="M:System.Diagnostics.Process.CloseMainWindow" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public int WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WorkingSet { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int" Usage="System.Diagnostics.Process.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use WorkingSet64")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This property has been deprecated.  Please use System.Diagnostics.Process.WorkingSet64 instead.  https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém o uso de memória física do processo associado, em bytes.</summary>
        <value>A quantidade total de memória física usada pelo processo associado, em bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual do trabalho de memória de conjunto usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo os módulos de processo e as bibliotecas do sistema.  
  
   
  
## Examples  
 O exemplo a seguir inicia uma instância do bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe o código de saída do processo.  
  
 [!code-cpp[process_sample#1](~/samples/snippets/cpp/VS_Snippets_CLR/process_sample/CPP/process_sample.cpp#1)]
 [!code-csharp[process_sample#1](~/samples/snippets/csharp/VS_Snippets_CLR/process_sample/CS/process_sample.cs#1)]
 [!code-vb[process_sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/process_sample/VB/process_sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
        <altmember cref="P:System.Diagnostics.Process.WorkingSet64" />
      </Docs>
    </Member>
    <Member MemberName="WorkingSet64">
      <MemberSignature Language="C#" Value="public long WorkingSet64 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 WorkingSet64" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Process.WorkingSet64" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WorkingSet64 As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long WorkingSet64 { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet64 : int64" Usage="System.Diagnostics.Process.WorkingSet64" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Diagnostics.Process</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Diagnostics.MonitoringDescription("The amount of physical memory currently used for this process.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Diagnostics.MonitoringDescription("ProcessWorkingSet")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtém a quantidade de memória física, em bytes, alocada para o processo associado.</summary>
        <value>A quantidade de memória física, em bytes, alocada para o processo associado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor retornado por essa propriedade representa o tamanho atual do trabalho de memória de conjunto usada pelo processo, em bytes. O conjunto de trabalho de um processo é o conjunto de páginas de memória atualmente visíveis para o processo na memória RAM física. Essas páginas são residentes e disponíveis para um aplicativo para usar sem disparar uma falha de página.  
  
 O conjunto de trabalho inclui dados compartilhados e privados. Os dados compartilhados incluem as páginas que contêm todas as instruções que o processo é executado, incluindo instruções sobre os módulos de processo e as bibliotecas do sistema.  
  
 Essa propriedade pode ser usada para monitorar o uso de memória em computadores com processadores de 32 bits ou processadores de 64 bits. O valor da propriedade é equivalente à **conjunto de trabalho** contador de desempenho para o processo.  
  
   
  
## Examples  
 O exemplo de código a seguir inicia uma instância do aplicativo bloco de notas. O exemplo, em seguida, recupera e exibe várias propriedades do processo associado. O exemplo detecta quando o processo é encerrado e exibe suas estatísticas sair de memória de código e de pico.  
  
 [!code-cpp[Diag_Process_MemoryProperties64#1](~/samples/snippets/cpp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CPP/source.cpp#1)]
 [!code-csharp[Diag_Process_MemoryProperties64#1](~/samples/snippets/csharp/VS_Snippets_CLR/Diag_Process_MemoryProperties64/CS/source.cs#1)]
 [!code-vb[Diag_Process_MemoryProperties64#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Diag_Process_MemoryProperties64/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">A plataforma é Windows 98 ou Windows Millennium Edition (Windows Me), que não dá suporte a essa propriedade.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">para confiança total do chamador imediato. Este membro não pode ser usado pelo código parcialmente confiável.</permission>
        <altmember cref="P:System.Diagnostics.Process.MinWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.MaxWorkingSet" />
        <altmember cref="P:System.Diagnostics.Process.PeakWorkingSet64" />
      </Docs>
    </Member>
  </Members>
</Type>