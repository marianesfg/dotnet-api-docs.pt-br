<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XamlReader.xml" source-language="en-US" target-language="pt-BR">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cb6251512dd75740e1b01a33ceb7e3470f3a68d1.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cb6251512dd75740e1b01a33ceb7e3470f3a68d1</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and creates an object graph, using the WPF default XAML reader and an associated XAML object writer.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The synchronous <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> methods are static, but the asynchronous <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> methods are not static and require an instance of the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class to use.</source>
          <target state="translated">Síncronos <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> métodos são estáticos, mas o assíncrona <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> métodos não são estáticos e requer uma instância do <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe a ser usada.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The output of the <ph id="ph1">`Load`</ph> methods is a single object, which represents the root object of a created object tree or object graph.</source>
          <target state="translated">A saída de <ph id="ph1">`Load`</ph> métodos é um único objeto, que representa o objeto raiz de uma árvore de objeto criado ou um gráfico de objeto.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Object graphs that are created by <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> are typically added to the existing object tree of a WPF application at run time.</source>
          <target state="translated">Objetos gráficos que são criados por <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> normalmente são adicionados à árvore de objetos existentes de um aplicativo do WPF no tempo de execução.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Otherwise the new object graph is considered disconnected for purposes of the WPF application model.</source>
          <target state="translated">Caso contrário, o novo gráfico de objeto é considerado desconectado para fins do modelo de aplicativo do WPF.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that it does not render, and cannot be accessed using any of the object tree techniques as applied to the WPF application's main object tree (for example, the APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</source>
          <target state="translated">Isso significa que ele não renderizar e não pode ser acessados usar as técnicas de árvore de objeto como aplicada à árvore de objeto principal do aplicativo do WPF (por exemplo, as APIs <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information on object tree concepts, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Para obter mais informações sobre os conceitos de árvore de objeto, consulte <bpt id="p1">[</bpt>árvores no WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> supports the following primary scenarios:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> suporta os seguintes cenários principais:</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Cloning/object factory<ept id="p1">**</ept>: Without additional mechanisms, a reference type generally cannot be included in more than one position in a WPF object tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>Fábrica de clonagem/objeto<ept id="p1">**</ept>: sem mecanismos adicionais, um tipo de referência geralmente não pode ser incluído em mais de uma posição em uma árvore de objetos do WPF.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>(Examples of additional mechanisms that offer support for sharing or re-use in WPF include objects that are based on <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, or support for commonly shareable objects such as <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> that are referenced as an item from a <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) One way to clone an object that is already in the object tree is to serialize the object using <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">(Exemplos de mecanismos adicionais que oferecem suporte para o compartilhamento ou reutilizar em WPF objetos baseados em <ph id="ph1">&lt;xref:System.Windows.Freezable&gt;</ph>, ou suporte para objetos normalmente podem ser compartilhados como <ph id="ph2">&lt;xref:System.Windows.Media.Brush&gt;</ph> que são referenciados como um item de um <ph id="ph3">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.) Uma forma para clonar um objeto que já está no árvore de objetos é serializar o objeto usando <ph id="ph4">&lt;xref:System.Windows.Markup.XamlWriter.Save%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You then use the serialized string as input for a call to <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, with a stream or <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> as an intermediary.</source>
          <target state="translated">Em seguida, a cadeia de caracteres serializada é usada como entrada para uma chamada para <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph>, com um fluxo ou <ph id="ph2">&lt;xref:System.Xml.XmlReader&gt;</ph> como um intermediário.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Constructing objects based on just-in-time information<ept id="p1">**</ept>: There are often other ways to have late-binding or user-supplied input change the state of existing objects.</source>
          <target state="translated"><bpt id="p1">**</bpt>Construindo objetos com base nas informações de just-in-time<ept id="p1">**</ept>: frequentemente, há outras maneiras de ter entrada de associação tardia ou fornecido pelo usuário a alterar o estado de objetos existentes.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For example you could use the same value to set more than one property, or use data binding.</source>
          <target state="translated">Por exemplo você pode usar o mesmo valor para definir mais de uma propriedade ou usar associação de dados.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>But if you have a scenario where even the type of object to create is only determinable at run time or with user interaction, then creating such an object by building up a string for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> input is often a useful technique.</source>
          <target state="translated">Mas se você tiver um cenário em que até mesmo o tipo de objeto para criar só está determinável em tempo de execução ou a interação do usuário, criando esse tipo de objeto, criando uma cadeia de caracteres para <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> entrada geralmente é uma técnica útil.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Using existing resource techniques<ept id="p1">**</ept>: The <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> type is used frequently in other frameworks or technologies for transferring data or objects across application boundaries or for similar situations.</source>
          <target state="translated"><bpt id="p1">**</bpt>Usando técnicas de recurso existente<ept id="p1">**</ept>: O <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> tipo é usado frequentemente em outras estruturas ou tecnologias para a transferência de dados ou objetos além dos limites do aplicativo ou em situações semelhantes.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can then use the <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> techniques to store or obtain XAML-formatted data that you eventually use to create an object as part of your application.</source>
          <target state="translated">Você pode usar o <ph id="ph1">&lt;xref:System.IO.Stream&gt;</ph> técnicas para armazenar ou obter dados formatados em XAML que você poderá usar para criar um objeto como parte do seu aplicativo.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><bpt id="p1">**</bpt>Fixed documents:<ept id="p1">**</ept> Your application might load local or downloaded XPS documents for inclusion in a WPF application object tree and UI.</source>
          <target state="translated"><bpt id="p1">**</bpt>Documentos fixos:<ept id="p1">**</ept> seu aplicativo pode carregar documentos XPS de local ou baixados para inclusão em uma árvore de objetos de aplicativo do WPF e a interface do usuário.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This documentation sometimes describes an object graph, as opposed to an object tree.</source>
          <target state="translated">Às vezes, esta documentação descreve um gráfico de objeto, em vez de uma árvore de objetos.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>A strict parent-child relationship does not always exist in the run time object relationships of a run time WPF application, so an object graph is a more widely applicable terminology.</source>
          <target state="translated">Uma relação pai-filho estrita não sempre existem nas relações de objeto de tempo de execução de um aplicativo do WPF de tempo de execução, portanto, um gráfico de objeto é uma terminologia mais amplamente aplicável.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, because WPF also includes two different tree conceptualization APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) the tree metaphor still applies adequately to most real-world cases in WPF.</source>
          <target state="translated">No entanto, como WPF também inclui conceituação passando árvore diferente duas APIs (<ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>) a metáfora de árvore ainda se aplica adequado para a maioria dos casos reais no WPF.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>From the XAML language perspective however, the object graph is often the best way to think about how objects are created out of XAML, because the XAML language itself does not necessarily specify helper class methodologies that bring the relationships more into a tree structure again.</source>
          <target state="translated">Da perspectiva de linguagem XAML no entanto, o gráfico de objeto é geralmente a melhor maneira de pensar sobre como os objetos são criados fora do XAML, como a linguagem XAML em si não especifica necessariamente metodologias de classe auxiliar que trazem as relações mais em uma estrutura de árvore novamente.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Code Access Security, Loose XAML, and XamlReader</source>
          <target state="translated">Segurança de acesso do código XAML livre e XamlReader</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>XAML is a markup language that directly represents object instantiation and execution.</source>
          <target state="translated">XAML é uma linguagem de marcação que representa diretamente a instanciação e execução de objetos.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore, elements created in XAML have the same ability to interact with system resources (network access, file system IO, for example) as the equivalent generated code does.</source>
          <target state="translated">Portanto, elementos criados em XAML têm a mesma capacidade que o código gerado equivalente no que se refere a interagir com recursos de sistema (acesso a rede e E/S do sistema de arquivos, por exemplo).</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> supports the <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> security framework <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> oferece suporte a <ph id="ph2">[!INCLUDE[TLA2#tla_net](~/includes/tla2sharptla-net-md.md)]</ph> estrutura de segurança <ph id="ph3">[!INCLUDE[TLA#tla_cas](~/includes/tlasharptla-cas-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>This means that <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> content running in the internet zone has reduced execution permissions.</source>
          <target state="translated">Isso significa que conteúdo do <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> em execução na zona da Internet tem permissões de execução reduzidas.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>"Loose XAML" (pages of noncompiled XAML interpreted at load time by a XAML viewer) and <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> are usually run in this internet zone and use the same permission set.</source>
          <target state="translated">"XAML avulso" (páginas de XAML não compilado interpretado na hora do carregamento por um visualizador XAML) e <ph id="ph1">[!INCLUDE[TLA#tla_xbap](~/includes/tlasharptla-xbap-md.md)]</ph> geralmente são executados nesta zona da Internet e usam o mesmo conjunto de permissões.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, XAML loaded in to a fully trusted application has the same access to the system resources as the hosting application does.</source>
          <target state="translated">No entanto, o XAML carregado em um aplicativo totalmente confiável tem o mesmo acesso aos recursos de sistema que o aplicativo host.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For more information, see <bpt id="p1">[</bpt>WPF Partial Trust Security<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</source>
          <target state="translated">Para obter mais informações, consulte <bpt id="p1">[</bpt>Segurança parcialmente confiável do WPF<ept id="p1">](~/docs/framework/wpf/wpf-partial-trust-security.md)</ept>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The implications of these statements for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is that your application design must make trust decisions about the XAML you decide to load.</source>
          <target state="translated">As implicações dessas instruções para <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> é que o design do aplicativo deve fazer as decisões de confiança sobre o XAML decidir carregar.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading XAML that is not trusted, consider implementing your own sandboxing technique for how you load the resulting object graph.</source>
          <target state="translated">Se você estiver carregando XAML que não é confiável, considere implementar seu próprio técnica no modo seguro para como carregar o gráfico de objeto resultante.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> can also be called by partial trust code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> também pode ser chamado por código parcialmente confiável.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In this case, Internet security zone is applied for code access security.</source>
          <target state="translated">Nesse caso, a zona de segurança é aplicada para a segurança de acesso do código.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If anything in the loaded XAML is invalid under Internet security zone, a XAML parse exception is thrown.</source>
          <target state="translated">Se qualquer coisa no XAML carregado é inválida na zona de segurança da Internet, é gerada uma exceção de análise XAML.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Under XBAP and other cases that are partial trust at the platform level, where <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is part of the execution, you get the same exception behavior as with explicit partial trust calls.</source>
          <target state="translated">Em outros casos que são de confiança parcial no nível da plataforma, e XBAP onde <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> faz parte da execução, você deve obter o mesmo comportamento de exceção como com chamadas explícitas de confiança parcial.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF XAML, XAML Readers/Writers, and XAML Language Versioning</source>
          <target state="translated">WPF XAML, leitores XAML/gravadores e controle de versão de linguagem XAML</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> includes language features such as  and .</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[xaml2009](~/includes/xaml2009-md.md)]</ph> inclui recursos de linguagem, como e.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>You can use signatures of <ph id="ph1">`Load`</ph> or <ph id="ph2">`Parse`</ph> to load XAML that uses these features.</source>
          <target state="translated">Você pode usar assinaturas de <ph id="ph1">`Load`</ph> ou <ph id="ph2">`Parse`</ph> para carregar o XAML que usa esses recursos.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, those language features are not supported for XAML that needs to be markup compiled (such as XAML for the <bpt id="p1">**</bpt>Page<ept id="p1">**</ept> build action in a WPF application, or any XAML that involves the markup compile task in the build actions).</source>
          <target state="translated">No entanto, esses recursos de idioma não há suporte para XAML que deve ser compilada com marcação (como o XAML para o <bpt id="p1">**</bpt>página<ept id="p1">**</ept> ação em um aplicativo do WPF ou qualquer XAML que envolve a tarefa de compilação de marcação nas ações de compilação de compilação).</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>WPF types and the WPF technology in general support concepts that rely on access to WPF internals.</source>
          <target state="translated">Tipos WPF e a tecnologia WPF em geral oferecem suporte a conceitos que dependem do acesso aos recursos internos do WPF.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>For instance, how WPF implements dependency properties relies on internal techniques for efficient type-member lookup.</source>
          <target state="translated">Por exemplo, como o WPF implementa propriedades de dependência depende de técnicas internas para pesquisa de membro de tipo eficiente.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Access to these internals is enabled by the XAML reading and writing APIs provided in <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> from the <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace and PresentationFramework assembly.</source>
          <target state="translated">Acesso a esses recursos internos é habilitado por XAML lendo e gravando APIs fornecidas no <ph id="ph1">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> e <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> do <ph id="ph3">&lt;xref:System.Windows.Markup&gt;</ph> namespace e assembly PresentationFramework.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>However, the lower-level XAML readers and XAML writers from the System.Xaml assembly (classes based on <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) do not have access to the WPF internals.</source>
          <target state="translated">No entanto, os leitores XAML de nível inferior e autores de XAML do assembly System. XAML (classes com base em <ph id="ph1">&lt;xref:System.Xaml.XamlReader?displayProperty=nameWithType&gt;</ph>, <ph id="ph2">&lt;xref:System.Xaml.XamlWriter?displayProperty=nameWithType&gt;</ph>) não tem acesso para a parte interna do WPF.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>There is no dependency from System.Xaml to any WPF-specific assembly.</source>
          <target state="translated">Não há nenhuma dependência de System. XAML para qualquer conjunto específico de WPF.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Without access to the WPF internals, System.Xaml readers and writers cannot correctly load or save all WPF types, or types based on WPF types.</source>
          <target state="translated">Sem acesso a itens internos WPF, gravadores e leitores de System. XAML não é possível carregar corretamente ou salvar WPF todos os tipos ou tipos com base nos tipos WPF.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>In particular, the System.Xaml readers and writers do not understand concepts such as the WPF dependency property backing property store, or all the specifics of how WPF uses styles, resource dictionaries and templates.</source>
          <target state="translated">Em particular, o System. XAML leitores e gravadores não entende conceitos como a propriedade de dependência do WPF fazendo o armazenamento de propriedades ou todas as especificações de como o WPF usa estilos, dicionários de recursos e modelos.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Therefore you have a choice to make:</source>
          <target state="translated">Portanto, você pode escolher fazer:</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are loading WPF types, and/or you are using XAML in BAML form in any way, use the PresentationFramework XAML readers and XAML writers.</source>
          <target state="translated">Se você estiver carregando tipos WPF e/ou você estiver usando o XAML em forma BAML de qualquer forma, use os leitores PresentationFramework XAML e autores de XAML.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are not relying on any WPF types or the BAML form of XAML, and are not using another specific technology's XAML reader or XAML writer implementation for reasons that are specific to that framework, use the System.Xaml XAML readers and XAML writers.</source>
          <target state="translated">Se você não depender de qualquer tipo WPF ou o formulário BAML de XAML e não estiver usando o leitor XAML ou a implementação de gravador XAML outra tecnologia específica por razões que são específicos para a essa estrutura, use os leitores de System XAML e gravadores XAML.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>System.Xaml Backing Implementation in .NET 4</source>
          <target state="translated">System. XAML fazendo implementação no .NET 4</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> is the callable API surface for the WPF framework-level XAML parser.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> é a superfície de API que pode ser chamada para o analisador XAML de nível de framework do WPF.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The same underlying XAML parser also performs the run-time XAML loading and parsing for WPF applications that target <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> and <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</source>
          <target state="translated">O analisador XAML subjacente mesmo também executa o XAML do tempo de execução, carregando e analisando o destino para aplicativos do WPF <ph id="ph1">[!INCLUDE[net_v30_short](~/includes/net-v30-short-md.md)]</ph> e <ph id="ph2">[!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>If you are targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, the external API is the same, but parts of the implementation are built on the <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> general XAML implementation in the System.Xaml assembly, which improves many of the technical and reporting aspects of parsing XAML.</source>
          <target state="translated">Se estiver direcionando <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph>, a API externa é o mesmo, mas partes da implementação baseiam-se no <ph id="ph2">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> implementação geral do XAML no assembly System. XAML, o que melhora a muitos aspectos técnicos e relatórios de análise de XAML.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>Targeting <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessarily entails including System.Xaml as a reference, and details of implementation such as the exceptions reported may come from System.Xaml defined types.</source>
          <target state="translated">Direcionamento <ph id="ph1">[!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]</ph> necessariamente tipos definidos de infere incluindo System. XAML como uma referência e os detalhes de implementação, como as exceções relatadas podem vir de System. XAML.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">O exemplo a seguir converte um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> em uma cadeia de caracteres usando o <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.Markup.XamlReader">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">A cadeia de caracteres, em seguida, é carregada de volta em um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> usando estático <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> método sobre o <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph> class.</source>
          
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source>Aborts the current asynchronous load operation, if there is an asynchronous load operation pending.</source>
          
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.CancelAsync">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> is an asynchronous operation; therefore, some loading may occur before the operation is aborted.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.CancelAsync%2A&gt;</ph> é uma operação assíncrona; Portanto, alguns carregamento pode ocorrer antes que a operação é anulada.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.GetWpfSchemaContext">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlSchemaContext" /&gt;</ph> object that represents the WPF schema context settings for a <ph id="ph2">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML input and returns the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The XAML to load, in stream form.</source>
          
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an <ph id="ph2">&lt;see cref="T:System.Object" /&gt;</ph> that is the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The object at the root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The following example saves a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> using the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">O exemplo a seguir salva um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> em uma <ph id="ph2">&lt;xref:System.IO.MemoryStream&gt;</ph> usando o <ph id="ph3">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source>The stream is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">O fluxo, em seguida, é carregado para um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> usando estático <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> método no <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> object.</source>
          
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is expected to be initialized with input XAML.</source>
          
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>Reads the XAML input through a provided <ph id="ph1">&lt;see cref="T:System.Xaml.XamlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The object that is the root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>The input <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> can be <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</source>
          <target state="translated">A entrada <ph id="ph1">&lt;xref:System.Xaml.XamlReader&gt;</ph> pode ser <ph id="ph2">&lt;xref:System.Windows.Baml2006.Baml2006Reader&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source>This is how you can load BAML at run time, or for localization tool purposes.</source>
          <target state="translated">Isso é como você pode carregar BAML em tempo de execução, ou para fins de ferramenta de localização.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xaml.XamlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded the XAML input to load in XML form.</source>
          
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The object that is the root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The following example converts a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> into a string using the <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> class.</source>
          <target state="translated">O exemplo a seguir converte um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> em uma cadeia de caracteres usando o <ph id="ph2">&lt;xref:System.Windows.Markup.XamlWriter&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source>The string is then loaded back into a <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> using the static <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> method on the <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class.</source>
          <target state="translated">A cadeia de caracteres, em seguida, é carregada de volta em um <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> usando estático <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> método sobre o <ph id="ph3">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The stream that contains the XAML input to load.</source>
          
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns an object that is the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The object that is the root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>-or-</source>
          
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Load(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="parserContext" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads XAML markup and returns an object that corresponds to the root of the specified markup.</source>
          
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The stream containing the XAML input to load.</source>
          
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The object that is the root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Uma operação assíncrona de carregamento XAML inicialmente retornará um objeto que é exclusivamente o objeto raiz.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">De forma assíncrona, análise de XAML, em seguida, continua e quaisquer objetos filho são preenchidos na raiz do.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Isso está em contraste com o XAML WPF típico processamento comportamento e sua interação com os conceitos do WPF do tempo de vida do objeto.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Na interação típica (não assíncronas), todas as propriedades de um objeto, incluindo todas as coleções filho são preenchidas antes de retornar um elemento e relatá-las como carregado.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Esse comportamento é igual a uma metodologia de baixo para cima para criar a árvore de onde o objeto raiz é o último objeto se torne disponível.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>You typically would assign the returned object to some location in your WPF application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Você normalmente atribua o objeto retornado para um local na árvore de objetos do aplicativo WPF, com o conhecimento de conteúdo pode ainda ser preencher e pode fazer com que as atualizações de layout incrementais se todo o conteúdo é exposto como parte da interface do usuário.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Por isso é típico para isolar ou virtualização de todos os objetos carregados de forma assíncrona do XAML e usar lógica específica do aplicativo ou o estado do aplicativo a ser notificado quando <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> é tratado.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML input must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Para que <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> para carregar o XAML de forma assíncrona de entrada, o elemento raiz no XAML de entrada deve conter o atributo e o valor <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">O valor é tratado como maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If the XAML input root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</source>
          <target state="translated">Se a raiz de entrada de XAML não contém <ph id="ph1">`x:SynchronousMode="Async"`</ph>, nenhuma exceção é lançada e a chamada é processada como uma carga síncrona (consulte <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Apenas uma operação de carregamento assíncrono por instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe pode ser executada por vez.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Se mais de uma operação assíncrona é tentada na mesma instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe um <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream)">
          <source>Multiple load operations are pending concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An existing  <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> that has already loaded/read the XAML input.</source>
          
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.Xml.XmlReader" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Uma operação assíncrona de carregamento XAML inicialmente retornará um objeto que é exclusivamente o objeto raiz.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">De forma assíncrona, análise de XAML, em seguida, continua e quaisquer objetos filho são preenchidos na raiz do.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Isso está em contraste com o XAML WPF típico processamento comportamento e sua interação com os conceitos do WPF do tempo de vida do objeto.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Na interação típica (não assíncronas), todas as propriedades de um objeto, incluindo todas as coleções filho são preenchidas antes de retornar um elemento e relatá-las como carregado.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Esse comportamento é igual a uma metodologia de baixo para cima para criar a árvore de onde o objeto raiz é o último objeto se torne disponível.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>You typically would assign the returned object from <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Você normalmente atribui o objeto retornado de <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> para um local na árvore de objetos do aplicativo, o conhecimento que o conteúdo pode ainda ser preencher e pode fazer com que as atualizações de layout incrementais se todo o conteúdo é exposto como parte da interface do usuário.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Por isso é típico para isolar ou virtualização de todos os objetos carregados de forma assíncrona do XAML e usar lógica específica do aplicativo ou o estado do aplicativo a ser notificado quando <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> é tratado.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load XAML input asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Para que <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> para carregar o XAML de forma assíncrona de entrada, o elemento raiz na marcação XAML deve conter o atributo e o valor <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">O valor é tratado como maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is instead processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</source>
          <target state="translated">Se a raiz de marcação XAML não contém <ph id="ph1">`x:SynchronousMode="Async"`</ph>, nenhuma exceção é lançada e a chamada é processada em vez disso, como uma carga síncrona (consulte <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.Xml.XmlReader%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Apenas uma operação de carregamento assíncrono por instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe pode ser executada por vez.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Se mais de uma operação assíncrona é tentada na mesma instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe um <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source><ph id="ph1">&lt;paramref name="reader" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.Xml.XmlReader)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>A stream containing the XAML input to load.</source>
          
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML input in the specified <ph id="ph1">&lt;see cref="T:System.IO.Stream" /&gt;</ph> and returns the root of the corresponding object tree.</source>
          
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>An asynchronous XAML load operation will initially return an object that is purely the root object.</source>
          <target state="translated">Uma operação assíncrona de carregamento XAML inicialmente retornará um objeto que é exclusivamente o objeto raiz.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Asynchronously, XAML parsing then continues, and any child objects are filled in under the root.</source>
          <target state="translated">De forma assíncrona, análise de XAML, em seguida, continua e quaisquer objetos filho são preenchidos na raiz do.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>This is in contrast to the typical WPF XAML processing behavior and its interaction with WPF concepts of object lifetime.</source>
          <target state="translated">Isso está em contraste com o XAML WPF típico processamento comportamento e sua interação com os conceitos do WPF do tempo de vida do objeto.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In the typical (non-async) interaction, all properties of an object including all child collections are filled before returning an element and reporting it as loaded.</source>
          <target state="translated">Na interação típica (não assíncronas), todas as propriedades de um objeto, incluindo todas as coleções filho são preenchidas antes de retornar um elemento e relatá-las como carregado.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>That behavior equates to a bottom-up methodology for creating the tree where the root object is the last object to become available.</source>
          <target state="translated">Esse comportamento é igual a uma metodologia de baixo para cima para criar a árvore de onde o objeto raiz é o último objeto se torne disponível.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>You typically would assign the returned object to some location in your application's object tree, with the knowledge that content might still be filling in and might cause incremental layout updates if the entire content is exposed as part of the UI.</source>
          <target state="translated">Você normalmente atribua o objeto retornado para um local na árvore de objetos do aplicativo, com o conhecimento de conteúdo pode ainda ser preencher e pode fazer com que as atualizações de layout incrementais se todo o conteúdo é exposto como parte da interface do usuário.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>For this reason it is typical to isolate or virtualize any asynchronously loaded objects from XAML, and to use application-specific logic or application state to notify when <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is handled.</source>
          <target state="translated">Por isso é típico para isolar ou virtualização de todos os objetos carregados de forma assíncrona do XAML e usar lógica específica do aplicativo ou o estado do aplicativo a ser notificado quando <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> é tratado.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>In order for <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> to load markup asynchronously, the root element in the XAML markup must contain the attribute and value <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</source>
          <target state="translated">Para que <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadAsync%2A&gt;</ph> para carregar marcação de forma assíncrona, o elemento raiz na marcação XAML deve conter o atributo e o valor <ph id="ph2">`x:SynchronousMode="Async"`</ph>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>The value is treated as case sensitive.</source>
          <target state="translated">O valor é tratado como maiusculas e minúsculas.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If the XAML markup root does not contain <ph id="ph1">`x:SynchronousMode="Async"`</ph>, no exception is thrown, and the call is processed as a synchronous load (see <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</source>
          <target state="translated">Se a raiz de marcação XAML não contém <ph id="ph1">`x:SynchronousMode="Async"`</ph>, nenhuma exceção é lançada e a chamada é processada como uma carga síncrona (consulte <ph id="ph2">&lt;xref:System.Windows.Markup.XamlReader.Load%28System.IO.Stream%2CSystem.Windows.Markup.ParserContext%29&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Only one asynchronous load operation per instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class can be performed at a time.</source>
          <target state="translated">Apenas uma operação de carregamento assíncrono por instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe pode ser executada por vez.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>If more than one asynchronous operation is attempted on the same instance of the <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> class an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> is thrown.</source>
          <target state="translated">Se mais de uma operação assíncrona é tentada na mesma instância do <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader&gt;</ph> classe um <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> é gerada.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source><ph id="ph1">&lt;paramref name="stream" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.LoadAsync(System.IO.Stream,System.Windows.Markup.ParserContext)">
          <source>Multiple load operations are performed concurrently with the same <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XamlReader" /&gt;</ph>.</source>
          
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source>Occurs when an asynchronous load operation completes.</source>
          
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.Markup.XamlReader.LoadCompleted">
          <source><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> is also raised when an asynchronous load operation aborts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.LoadCompleted&gt;</ph> também é gerado quando anula uma operação de carregamento assíncrono.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="T:System.Windows.Markup.XamlReader">
          <source>Reads the markup in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The input XAML, as a single text string.</source>
          
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>Reads the XAML input in the specified text string and returns an object that corresponds to the root of the specified markup.</source>
          
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">As chamadas de implementação <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internamente após a criação de um fluxo de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> para obter informações adicionais, como possíveis exceções.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The input XAML, as a single text string.</source>
          
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Context information used by the parser.</source>
          
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>Reads the XAML markup in the specified text string (using a specified <ph id="ph1">&lt;see cref="T:System.Windows.Markup.ParserContext" /&gt;</ph>) and returns an object that corresponds to the root of the specified markup.</source>
          
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The root of the created object tree.</source>
          
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>The implementation calls <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internally after creating a stream from the string.</source>
          <target state="translated">As chamadas de implementação <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> internamente após a criação de um fluxo de cadeia de caracteres.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.Markup.XamlReader.Parse(System.String,System.Windows.Markup.ParserContext)">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> for additional information such as possible exceptions.</source>
          <target state="translated">Consulte <ph id="ph1">&lt;xref:System.Windows.Markup.XamlReader.Load%2A&gt;</ph> para obter informações adicionais, como possíveis exceções.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>