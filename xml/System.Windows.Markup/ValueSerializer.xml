<Type Name="ValueSerializer" FullName="System.Windows.Markup.ValueSerializer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="44894f140207ce0b9641da2f3474f8800d70ba57" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="pt-BR" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36501835" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ValueSerializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract ValueSerializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Markup.ValueSerializer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ValueSerializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class ValueSerializer abstract" />
  <TypeSignature Language="F#" Value="type ValueSerializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Xaml</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("WindowsBase, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Classe abstrata que define o comportamento de conversão para a serialização de uma representação de objeto.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A cadeia de caracteres que retorna um conversor para serialização deve ser sem perdas e o conversor deve sempre retornar a mesma cadeia de caracteres para um valor específico.  Se um conversor de tipo (derivado de <xref:System.ComponentModel.TypeConverter>) não atender a esses requisitos em sua `ConvertTo` as implementações para saída de cadeia de caracteres, um personalizado <xref:System.Windows.Markup.ValueSerializer> devem ser declarados. Ou o <xref:System.Windows.Markup.ValueSerializer> devem atender os requisitos ou um valor nulo <xref:System.Windows.Markup.ValueSerializer> deve ser associado ao tipo. Um <xref:System.Windows.Markup.ValueSerializer> está associado um tipo, aplicando o <xref:System.Windows.Markup.ValueSerializerAttribute> atributo.  
  
 Um valor nulo <xref:System.Windows.Markup.ValueSerializer> indica o conversor de tipo deve ser ignorado para conversões de converter a cadeia de caracteres de gráfico do objeto.  
  
> [!IMPORTANT]
>  Implementação de <xref:System.Windows.Markup.ValueSerializer> deve evitar gerar exceções. As exceções geradas podem finalizar a serialização.  
  
 <xref:System.Windows.Markup.IValueSerializerContext> para uma <xref:System.Windows.Markup.ValueSerializer> e suas APIs é análogo ao <xref:System.ComponentModel.ITypeDescriptorContext> para um <xref:System.ComponentModel.TypeConverter>. Na verdade, <xref:System.Windows.Markup.IValueSerializerContext> herda <xref:System.ComponentModel.ITypeDescriptorContext>. Quando um <xref:System.Windows.Markup.ValueSerializer> classe derivada API é chamada, o chamador (geralmente um processo de serializador) passa um contexto que pode fornecer determinados serviços. Devido as diretrizes gerais que um <xref:System.Windows.Markup.ValueSerializer> não deve lançar exceções. Falha ao retornar um serviço específico do contexto também não deve lançar exceções.  
  
 Nas versões anteriores do .NET Framework, essa classe existia no assembly específicos de WPF WindowsBase. Em [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Windows.Markup.ValueSerializer> está no assembly System. XAML. Para obter mais informações, consulte [tipos migrados do WPF para System. XAML](~/docs/framework/xaml-services/types-migrated-from-wpf-to-system-xaml.md).  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Xaml.XamlXmlWriter" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ValueSerializer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ValueSerializer();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa uma nova instância da classe <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O corpo desse construtor está vazio. o <xref:System.Windows.Markup.ValueSerializer> classe não contém quaisquer valores que requerem inicialização.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertFromString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertFromString (value As String, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser avaliada para conversão.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Quando substituído em uma classe derivada, determina se o <see cref="T:System.String" /> especificado pode ser convertido em uma instância do tipo compatível com a implementação de <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>
          <see langword="true" /> se o valor puder ser convertido; caso contrário, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação base sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanConvertToString">
      <MemberSignature Language="C#" Value="public virtual bool CanConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.CanConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CanConvertToString (value As Object, context As IValueSerializerContext) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool&#xA;override this.CanConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; bool" Usage="valueSerializer.CanConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser avaliado para conversão.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Quando substituído em uma classe derivada, determina se o objeto especificado pode ser convertido em um <see cref="T:System.String" />.</summary>
        <returns>
          <see langword="true" /> se o <paramref name="value" /> puder ser convertido em um <see cref="T:System.String" />; caso contrário, <see langword="false." /></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação base sempre retorna `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConvertFromString">
      <MemberSignature Language="C#" Value="public virtual object ConvertFromString (string value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ConvertFromString(string value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertFromString(System.String,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertFromString (value As String, context As IValueSerializerContext) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ ConvertFromString(System::String ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj&#xA;override this.ConvertFromString : string * System.Windows.Markup.IValueSerializerContext -&gt; obj" Usage="valueSerializer.ConvertFromString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">A cadeia de caracteres a ser convertida.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Quando substituído em uma classe derivada, converte um <see cref="T:System.String" /> em uma instância do tipo compatível com a implementação de <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Uma nova instância do tipo compatível com a implementação de <see cref="T:System.Windows.Markup.ValueSerializer" /> com base no <paramref name="value" /> fornecido.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação base sempre gera uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="value" /> não pode ser convertido.</exception>
        <block subset="none" type="overrides">
          <para>Evite Lançando exceções a partir de implementações. Consulte <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ConvertToString">
      <MemberSignature Language="C#" Value="public virtual string ConvertToString (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ConvertToString(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.ConvertToString(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ConvertToString (value As Object, context As IValueSerializerContext) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ConvertToString(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string&#xA;override this.ConvertToString : obj * System.Windows.Markup.IValueSerializerContext -&gt; string" Usage="valueSerializer.ConvertToString (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">O objeto a ser convertido em uma cadeia de caracteres.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Quando substituído em uma classe derivada, converte o objeto especificado em um <see cref="T:System.String" />.</summary>
        <returns>Uma representação de cadeia de caracteres do objeto especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 A implementação base sempre gera uma exceção.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <paramref name="value" /> não pode ser convertido.</exception>
        <block subset="none" type="overrides">
          <para>Evite Lançando exceções a partir de implementações. Consulte <see cref="T:System.Windows.Markup.ValueSerializer" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetConvertFromException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertFromException (object value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertFromException(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertFromException(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertFromException (value As Object) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertFromException(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.GetConvertFromException : obj -&gt; Exception" Usage="valueSerializer.GetConvertFromException value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">O objeto não pôde ser convertido.</param>
        <summary>Retorna uma exceção a ser gerada quando uma conversão não puder ser executada.</summary>
        <returns>Um objeto <see cref="T:System.Exception" /> para a exceção a gerar quando uma conversão <see langword="ConvertFrom" /> não pode ser executada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor real `throw` palavra-chave não é invocada por esse método, portanto, o uso típico é `throw GetConvertFromException` (com parâmetros fornecidos).  
  
 A exceção específica retornado é <xref:System.InvalidOperationException>, com `value` passado na mensagem de exceção. O padrão de uso é igual de utilitários de exceção no <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConvertToException">
      <MemberSignature Language="C#" Value="protected Exception GetConvertToException (object value, Type destinationType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Exception GetConvertToException(object value, class System.Type destinationType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetConvertToException(System.Object,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Function GetConvertToException (value As Object, destinationType As Type) As Exception" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Exception ^ GetConvertToException(System::Object ^ value, Type ^ destinationType);" />
      <MemberSignature Language="F#" Value="member this.GetConvertToException : obj * Type -&gt; Exception" Usage="valueSerializer.GetConvertToException (value, destinationType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="destinationType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="value">O objeto não pôde ser convertido.</param>
        <param name="destinationType">Um tipo que representa o tipo no qual a conversão estava tentando converter.</param>
        <summary>Retorna uma exceção a ser gerada quando uma conversão não puder ser executada.</summary>
        <returns>Um objeto <see cref="T:System.Exception" /> para a exceção a gerar quando uma conversão <see langword="ConvertTo" /> não pode ser executada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 O valor real `throw` palavra-chave não é invocada por esse método, portanto, o uso típico é `throw GetConvertToException` (com `value` parâmetro fornecido).  
  
 A exceção específica retornado é <xref:System.InvalidOperationException>, com `value` passado na mensagem de exceção. O padrão de uso é igual de utilitários de exceção no <xref:System.ComponentModel.TypeConverter>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSerializerFor">
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Obtém o <see cref="T:System.Windows.Markup.ValueSerializer" /> para um objeto.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor descriptor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
      </Parameters>
      <Docs>
        <param name="descriptor">O descritor de propriedade CLR para a propriedade a ser serializada.</param>
        <summary>Obtém o <see cref="T:System.Windows.Markup.ValueSerializer" /> declarado para uma propriedade, passando um descritor de propriedade CLR para a propriedade.</summary>
        <returns>O serializador associado à propriedade especificada. Pode retornar <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Markup.ValueSerializer> para uma propriedade ou um tipo que é usado como o valor de uma propriedade, é indicado pela aplicação de <xref:System.Windows.Markup.ValueSerializerAttribute> atributo na declaração de propriedade ou o tipo. O <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> é um método de utilitário que lê as informações do sistema de tipo CLR e retorna um novo <xref:System.Windows.Markup.ValueSerializer> classe com base no atributo, se encontrado na propriedade, ou se, em seguida, no tipo da propriedade. `null` pode ser retornado se nenhum serializador tal existe. `null` também pode ser retornado se um tipo ou a propriedade deliberadamente é atribuída com um valor null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Outro modo que <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> suporta está retornando interno `TypeConverterValueSerializer` classe, que é um <xref:System.Windows.Markup.ValueSerializer> implementação que encapsula um <xref:System.ComponentModel.TypeConverter> e converte o `Convert` métodos para `Convert*String` métodos (por exemplo <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>é chamado com entrada o <xref:System.String> digite e se traduz em <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Isso é feito apenas em casos em que todos os itens a seguir forem verdadeiras:  
  
-   Um <xref:System.ComponentModel.TypeConverterAttribute> encontra-se a propriedade relevante ou o tipo da propriedade relevantes.  
  
-   O indicado <xref:System.ComponentModel.TypeConverter> pode ser criada com êxito.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
> [!NOTE]
>  A seguir são casos especiais: <xref:System.DateTime> tipos de retorno de um <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipos retornam um serializador interno, porém funcional (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descriptor" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual obter <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <summary>Obtém o <see cref="T:System.Windows.Markup.ValueSerializer" /> declarado para o tipo especificado.</summary>
        <returns>O serializador associado ao tipo especificado. Pode retornar <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um <xref:System.Windows.Markup.ValueSerializer> para um tipo é indicado com a aplicação de <xref:System.Windows.Markup.ValueSerializerAttribute> atributo na declaração de tipo. O <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> é um método de utilitário que lê as informações do sistema de tipo CLR e retorna um novo <xref:System.Windows.Markup.ValueSerializer> classe com base no atributo, se encontrado no especificado `type`. `null` pode ser retornado se nenhum serializador tal existe. `null` também pode ser retornado se um tipo é deliberadamente atribuído com um valor null <xref:System.Windows.Markup.ValueSerializerAttribute>.  
  
 Outro modo que <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%2A> suporta está retornando interno `TypeConverterValueSerializer` classe, que é um <xref:System.Windows.Markup.ValueSerializer> implementação que encapsula um <xref:System.ComponentModel.TypeConverter> e converte o `Convert` métodos para `Convert*String` métodos (por exemplo <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>é chamado com entrada o <xref:System.String> digite e se traduz em <xref:System.Windows.Markup.ValueSerializer.ConvertToString%2A>. Isso é feito apenas em casos em que todos os itens a seguir forem verdadeiras:  
  
-   Um <xref:System.ComponentModel.TypeConverterAttribute> foi encontrado no `type`.  
  
-   O indicado <xref:System.ComponentModel.TypeConverter> pode ser criada com êxito.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.ConvertTo%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
-   O <xref:System.ComponentModel.TypeConverter> retorna `true` para <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A?displayProperty=nameWithType>, chamado referenciando o <xref:System.String> tipo.  
  
> [!NOTE]
>  A seguir são casos especiais: <xref:System.DateTime> tipos de retorno de um <xref:System.Windows.Markup.DateTimeValueSerializer>; <xref:System.String> tipos retornam um serializador interno, porém funcional (`StringValueSerializer`).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (System.ComponentModel.PropertyDescriptor descriptor, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.ComponentModel.PropertyDescriptor descriptor, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.ComponentModel.PropertyDescriptor,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetSerializerFor (descriptor As PropertyDescriptor, context As IValueSerializerContext) As ValueSerializer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(System::ComponentModel::PropertyDescriptor ^ descriptor, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : System.ComponentModel.PropertyDescriptor * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (descriptor, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="descriptor" Type="System.ComponentModel.PropertyDescriptor" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="descriptor">Descritor da propriedade a ser serializada.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Obtém o <see cref="T:System.Windows.Markup.ValueSerializer" /> declarado para a propriedade especificada usando o contexto especificado.</summary>
        <returns>O serializador associado à propriedade especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de contar apenas em atributos relatado no sistema de tipos CLR, essa sobrecarga usa o `context` como um serviço e chama a implementação do serviço de <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. O <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementação também geralmente confiarão na `descriptor`, mas pode implementar o comportamento especial para determinados contextos.  
  
 Esse método deve ser chamado quando o chamador tem um <xref:System.Windows.Markup.IValueSerializerContext> de um serviço.  Isso irá assegurar que a correta <xref:System.Windows.Markup.ValueSerializer> é retornado para o contexto específico.  
  
 Se retorna o contexto `null` de seu <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> seu especificado `descriptor`, ou se o contexto especificado é `null`, e em seguida, o comportamento é idêntico a chamar o <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.ComponentModel.PropertyDescriptor%29> sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="descriptor" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetSerializerFor">
      <MemberSignature Language="C#" Value="public static System.Windows.Markup.ValueSerializer GetSerializerFor (Type type, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Markup.ValueSerializer GetSerializerFor(class System.Type type, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Markup::ValueSerializer ^ GetSerializerFor(Type ^ type, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="static member GetSerializerFor : Type * System.Windows.Markup.IValueSerializerContext -&gt; System.Windows.Markup.ValueSerializer" Usage="System.Windows.Markup.ValueSerializer.GetSerializerFor (type, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.ValueSerializer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="type">O tipo para o qual obter <see cref="T:System.Windows.Markup.ValueSerializer" />.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Obtém o <see cref="T:System.Windows.Markup.ValueSerializer" /> declarado para o tipo especificado usando o contexto especificado.</summary>
        <returns>O serializador associado ao tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Em vez de contar apenas em atributos relatado no sistema de tipos CLR, essa sobrecarga usa o `context` como um serviço e chama a implementação do serviço de <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType>. O <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> implementação também geralmente confiarão na `type`, mas pode implementar o comportamento especial para determinados contextos.  
  
 Esse método deve ser chamado quando o chamador tem um <xref:System.Windows.Markup.IValueSerializerContext> de um serviço. Isso irá assegurar que a correta <xref:System.Windows.Markup.ValueSerializer> é retornado para o contexto específico.  
  
 Se retorna o contexto `null` de seu <xref:System.Windows.Markup.IValueSerializerContext.GetValueSerializerFor%2A?displayProperty=nameWithType> seu especificado `type`, ou se o contexto especificado é `null`, e em seguida, o comportamento é idêntico a chamar o <xref:System.Windows.Markup.ValueSerializer.GetSerializerFor%28System.Type%29> sobrecarga.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> é <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeReferences">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; TypeReferences (object value, System.Windows.Markup.IValueSerializerContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; TypeReferences(object value, class System.Windows.Markup.IValueSerializerContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Markup.ValueSerializer.TypeReferences(System.Object,System.Windows.Markup.IValueSerializerContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function TypeReferences (value As Object, context As IValueSerializerContext) As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ TypeReferences(System::Object ^ value, System::Windows::Markup::IValueSerializerContext ^ context);" />
      <MemberSignature Language="F#" Value="abstract member TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;&#xA;override this.TypeReferences : obj * System.Windows.Markup.IValueSerializerContext -&gt; seq&lt;Type&gt;" Usage="valueSerializer.TypeReferences (value, context)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xaml</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="context" Type="System.Windows.Markup.IValueSerializerContext" />
      </Parameters>
      <Docs>
        <param name="value">O valor que está sendo serializado.</param>
        <param name="context">Informações de contexto que são usadas para conversão.</param>
        <summary>Obtém uma enumeração dos tipos referenciados pelo <see cref="T:System.Windows.Markup.ValueSerializer" />.</summary>
        <returns>Os tipos de convertidos por este serializador.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Quaisquer tipos um <xref:System.Windows.Markup.ValueSerializer> converte deve ser incluídos na enumeração retornada.  Isso permite que um serializador garantir que um serializador de tem informações suficientes sobre os tipos converte este serializador.  
  
 Substituir esse método é um cenário avançado. Substituindo é necessária somente se você estiver implementando um sistema onde relações sistema de propriedade ownertype do tipo CLR disponíveis em um contexto de esquema XAML não relatam informações suficientes.  
  
## <a name="wpf-usage-notes"></a>Notas de uso do WPF  
 O [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] sistema de propriedade implementa um serializador de valor interno que substitui <xref:System.Windows.Markup.ValueSerializer.TypeReferences%2A> porque uma propriedade de dependência tem um conceito que ele pode ter adicionado proprietários. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] expressões também têm tratamento interno especial.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>